#include-once
#include <Array.au3>
;#include <_debug.au3> Added func to end of this udf.
; ------------------------------------------------------------------------------
;
; AutoIt Version: 	3.0
; Language: 		English
; Description: 		Functions that assist with using xml files
;					Stephen Podhajecki <gehossafats@netmdc.com>
; Dec 15, 2005
; ------------------------------------------------------------------------------


;===============================================================================
; XML DOM Wrapper functions
;
; These funtions require beta as they need support for COM
;
;===============================================================================
#cs defs to add to au3.api
	_XMLCreateCDATA($sNode, $sCDATA) Create a CDATA SECTION node directly under root. (Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateChildNode($XPath, $sNode, [$sData = ""]) Create a child node under the specified XPath Node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateChildNodeWAttr($sXPath, $sNode, $avAttr, $avVal,[$sData =""]) Create a child node under the specified XPath Node with Attributes. (Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateComment($sNode, $sComment)Create a COMMENT node at specified path.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateFile($sPath, $sRootNode, [$bOverwrite = False]) Creates an XML file with the given name and root.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateRootChild($sNode) Create node directly under root.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateRootNodeWAttr($sNode, $avAttr, $avVal,[$sData=""]) Create a child node under root node with attributes.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLDeleteAttr($sXPath, $sAttrib) Delete attribute for specified XPath(Requires: #include <_XMLDomWrapper.au3>)
	_XMLDeleteAttrNode($sXPath, $sAttrib) Delete attribute node for specified XPath(Requires: #include <_XMLDomWrapper.au3>)
	_XMLDeleteNode($sXPath) Delete specified XPath node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLError($sError = "") Sets or Gets XML error message generated by XML functions.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLFileOpen($sXMLFile)Creates an instance of an XML file.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLGetAllAttrib($sXPath, [$sQuery = ""]) Get all XML Field(s) attributes based on XPath input from root node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLGetAttrib($sXPath, $sAttrib, $sQuery = "") Get XML attribute based on XPath input from root node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLGetField($sPath) Get XML Field(s) based on XPath input from root node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLSetAttrib($sPath, $sAttrib, $sValue = "") Set XML Field(s) attributes based on XPath input from root node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLUpdateField_XMLUpdateField($sXPath, $sData) Update existing node(s) based on XPath specs.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLSelectNodes($sXPath) Selects XML Node(s) based on XPath input from root node. (Requires: #include <_XMLDomWrapper.au3>)
#ce
;===============================================================================
;Global variables
Global $strFile;the current xml file name
Global $objDoc;then current XML object
;Global $objSel;Selection object
;Global $objXMLex    ;Exception handler object
;Global $COMErr_Silent = False ; Flag to display error msg or to allow calling function to handle it
Global $oMyError ;COM error handler OBJ ; Initialize SvenP 's  error handler
Global $sXML_error;Error message variable for XML errors
Global $debugging;flag for debug messages
;===============================================================================

;UDF functions

;===============================================================================
; Function Name:	 _XMLFileOpen
; Description:		Creates an instance of an XML file.
; Parameters:		$filename
; Syntax:			 _XMLFileOpen($strFile)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			1 on success -1 on failure
;===============================================================================
Func _XMLFileOpen($strXMLFile)
	;==== pick your poison
	;	$objDoc = ObjCreate("Microsoft.XMLDOM")
	$objDoc = ObjCreate("Msxml2.DOMDocument.3.0")
	;	$objDoc = ObjCreate("Msxml2.DOMDocument.4.0")
	$oMyError = ObjEvent("AutoIt.Error", "_COMerr") ; ; Initialize SvenP 's  error handler
	;	$objDoc.setProperty ("SelectionLanguage", "XPath")
	$objDoc.async = False
	$strFile = $strXMLFile
	$objDoc.Load ($strFile)
	If $objDoc.parseError.errorCode <> 0 Then
		_XMLError( "Error opening specified file: " & $strXMLFile & @CRLF & $objDoc.parseError.reason)
		SetError($objDoc.parseError.errorCode)
		Return -1
	EndIf
	Return 1
EndFunc   ;==>_XMLFileOpen

;===============================================================================
; Function Name:	_XMLCreateFile
; Description:		Create a new blank metafile with header.
; Parameters:		$filename	The xml filename with full path to create
;					$root		The root of the xml file to create
;					[overwrite] boolean flag to auto overwrite existing
;								xml file of same name. Defaults to false and
;								will prompt to overwrite.
;								Overwrite copies the file with the ext .old
;								Then deletes the original file.
; Syntax:			_XMLCreateFile($filename,$root,[flag])  flag is boolean
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			-1 on failure
;===============================================================================
Func _XMLCreateFile($strPath, $strRoot, $bOverwrite = False)
	Local $retval, $fe, $objPI, $objDoc, $rootElement
	$fe = FileExists($strPath)
	If $fe And Not $bOverwrite Then
		$retval = (MsgBox(4097, "File Exists:", "The specified file exits." & @CRLF & "Click OK to overwrite file or cancel to exit."))
		If $retval = 1 Then
			FileCopy($strPath, $strPath & ".old", 1)
			FileDelete($strPath)
			$fe = False
		Else
			_XMLError( "Error failed to create file: " & $strPath & @CRLF & "File exists.")
			SetError(1)
			Return -1
		EndIf
	Else
		FileCopy($strPath, $strPath & ".old", 1)
		FileDelete($strPath)
		$fe = False
	EndIf
	
	If $fe = False Then
		;==== pick your poison
		;	$objDoc = ObjCreate("Microsoft.XMLDOM")
		$objDoc = ObjCreate("Msxml2.DOMDocument.3.0")
		;	$objDoc = ObjCreate("Msxml2.DOMDocument.4.0")
		$objPI = $objDoc.createProcessingInstruction ("xml", "version=""1.0""")
		$objDoc.appendChild ($objPI)
		$rootElement = $objDoc.createElement ($strRoot)
		$objDoc.documentElement = $rootElement
		$objDoc.save ($strPath)
		If $objDoc.parseError.errorCode <> 0 Then
			;			_XMLError( "Error Creating specified file: " & $strPath & @CRLF & $oMyError.windescription)
			_XMLError( "Error Creating specified file: " & $strPath)
			SetError($objDoc.parseError.errorCode)
			Return -1
		EndIf
		Return
	Else
		_XMLError( "Error! Failed to create file: " & $strPath)
		SetError(1)
		Return -1
	EndIf
EndFunc   ;==>_XMLCreateFile
;===============================================================================
; Function Name:	_XMLSelectNodes
; Description:		Selects XML Node(s) based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
; Syntax:			_XMLDeleteNode($path)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of Nodes or -1 on failure
;===============================================================================
Func _XMLSelectNodes($strXPath)
	Local $objNode, $objNodeList, $arrResponse[1], $i
	$objNodeList = $objDoc.documentElement.selectNodes ($strXPath)
	While @error = 0
		If Not IsObj($objNode) Then $xmlerr = @CRLF & "No Matching Nodes found"
		For $objNode In $objNodeList
			_ArrayAdd($arrResponse, $objNode.nodeName)
			
		Next
		$arrResponse[0] = $objNodeList.length
		Return $arrResponse
	WEnd
	;	_XMLError( "Error Selecting Node(s): " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Selecting Node(s): " & $strXPath & $xmlerr)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLSelectNodes

;===============================================================================
; Function Name:	_XMLGetField
; Description:		Get XML Field(s) based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
; Syntax:			_XMLGetField($path)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of fields text values -1 on failure
;===============================================================================
Func _XMLGetField($strXPath)
	Local $objNodeList, $arrResponse[1], $i
	While @error = 0
		$objNodeList = $objDoc.documentElement.selectNodes ($strXPath)
		If $objNodeList.length > 0 Then
			_DebugWrite("GetField list length:" & $objNodeList.length)
			For $objNode In $objNodeList
				_ArrayAdd($arrResponse, $objNode.Text)
				_DebugWrite("GetField:" & $objNode.Text)
			Next
			$arrResponse[0] = $objNodeList.length
			Return $arrResponse
		Else
			$xmlerr = @CRLF & "No matching node(s)found!"
			ExitLoop
		EndIf
		
	WEnd
	;	_XMLError( "Error Retrieving: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Retrieving: " & $strXPath & $xmlerr)
	;			_XMLError( "No matching node(s)found for: " & $strXPath & @CRLF & $oMyError.windescription)
	SetError(1)
	Return -1
	
EndFunc   ;==>_XMLGetField
;===============================================================================
; Function Name:	_XMLGetValue
; Description:		Get XML Fieldbased on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
; Syntax:			_XMLGetValue($path)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of fields text values -1 on failure
;===============================================================================
Func _XMLGetValue($strXPath)
	Local $objNodeList, $arrResponse[1], $i
	While @error = 0
		$objNodeList = $objDoc.documentElement.selectNodes ($strXPath)
		If $objNodeList.length > 0 Then
			_DebugWrite("GetValue list length:" & $objNodeList.length)
			For $objNode In $objNodeList
				_ArrayAdd($arrResponse, $objNode.Text)
				_DebugWrite("GetValue:" & $objNode.Text)
			Next
			Return $objNode.Text
			;			Return $arrResponse
		Else
			$xmlerr = @CRLF & "No matching node(s)found!"
			ExitLoop
		EndIf
		
	WEnd
	;	_XMLError( "Error Retrieving: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Retrieving: " & $strXPath & $xmlerr)
	;			_XMLError( "No matching node(s)found for: " & $strXPath & @CRLF & $oMyError.windescription)
	SetError(1)
	Return -1
	
EndFunc   ;==>_XMLGetValue

;===============================================================================
; Function Name:	_XMLDeleteNode
; Description:		Deletes XML Node based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
; Syntax:			_XMLDeleteNode($path)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of fields text values   -1 on failure
;===============================================================================
Func _XMLDeleteNode($strXPath)
	Local $objNode, $arrResponse[1], $i
	$objNode = $objDoc.documentElement.selectSingleNode ($strXPath)
	If Not IsObj($objNode) Then $xmlerr = @CRLF & "Node Not found"
	While @error = 0 ;And $objNode.length > 0
		$objNode.parentNode.removeChild ($objNode)
		$objDoc.save ($strFile)
		Return
	WEnd
	;	_XMLError( "Error Deleting Node: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Deleting Node: " & $strXPath & $xmlerr)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLDeleteNode

;===============================================================================
; Function Name:	_XMLDeleteAttr
; Description:		Delete XML Attribute based on XPath input from root node.
; Parameters:		$path xml tree path from root node (root/child/child..)
;					$attribute The attribute node to delete
; Syntax:			_XMLDeleteAttr($path,$attribute)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			-1 on error and set error to 1
;===============================================================================
Func _XMLDeleteAttr($strXPath, $strAttrib)
	Local $objNode, $objAttr
	$objNode = $objDoc.documentElement.selectSingleNode ($strXPath)
	While @error = 0 And IsObj($objNode)
		$objAttr = $objNode.getAttributeNode ($strAttrib)
		If not (IsObj($objAttr)) Then
			$xmlerr = "Attribute " & $strAttrib & " does not exist!"
			ExitLoop
		EndIf
		$objAttr = $objNode.removeAttribute ($strAttrib)
		$objDoc.save ($strFile)
		Return
	WEnd
	;	_XMLError( "Error Deleting Node: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Removing Attribute: " & $strXPath & " - " & $strAttrib & @CRLF & $xmlerr)
	$xmlerr = ""
	SetError(1)
	Return -1
EndFunc   ;==>_XMLDeleteAttr

;===============================================================================
; Function Name:	_XMLDeleteAttrNode
; Description:		Delete XML Attribute node based on XPath input from root node.
; Parameters:		$path xml tree path from root node (root/child/child..)
;					$attribute The attribute node to delete
; Syntax:			_XMLDeleteAttrNode($path,$attribute)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			-1 on error and set error to 1
;===============================================================================
Func _XMLDeleteAttrNode($strXPath, $strAttrib)
	Local $objNode, $objAttr
	$objNode = $objDoc.documentElement.selectSingleNode ($strXPath)
	If Not IsObj($objNode) Then
		$xmlerr = @CRLF & "Specified node not found!"
	Else
		While @error = 0 ;and IsObj($objNode) ;getAttributeNode($strAttrib)
			$objAttr = $objNode.removeAttributeNode ($objNode.getAttributeNode ($strAttrib))
			$objDoc.save ($strFile)
			If not (IsObj($objAttr)) Then
				$xmlerr = @CRLF & "Unspecified error:!"
				ExitLoop
			EndIf
			Return
		WEnd
	EndIf
	;	_XMLError( "Error Deleting Node: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Removing Attribute Node: " & $strXPath & " - " & $strAttrib & $xmlerr)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLDeleteAttrNode

;===============================================================================
; Function Name:	_XMLGetAttrib
; Description:		Get XML Field(s) based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
; Syntax:			_XMLGetAttrib($path,$attrib)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of fields text values
;					on error set error to 1 and returns -1
;===============================================================================
Func _XMLGetAttrib($strXPath, $strAttrib, $strQuery = "")
	Local $objNodeList, $arrResponse[1], $i
	$objNodeList = $objDoc.documentElement.selectNodes ($strXPath & $strQuery)
	_DebugWrite("Get Attrib length= " & $objNodeList.length)
	;	If @error = 0 Then
	While @error = 0
		
		If $objNodeList.length > 0 Then
			;			_DebugWrite ("Length:" & $objNodeList.length)
			ReDim $arrResponse[$objNodeList.length]
			For $i = 0 To $objNodeList.length - 1
				$objAttr = $objNodeList.item ($i).getAttribute ($strAttrib)
				;				$arrResponse[$i] = $objAttr.text
				;				$arrResponse[$i] = $objAttr
				$arrResponse = $objAttr
				_DebugWrite("RET>>" & $objAttr)
				_DebugWrite("Text>>" & $objAttr.text)
			Next
			Return $arrResponse
		Else
			$xmlerr = @CRLF & "No qualified items found"
			ExitLoop
		EndIf
	WEnd
	
	;EndIf
	;	_XMLError( "Attribute " & $strAttrib & " not found for: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Attribute " & $strAttrib & " not found for: " & $strXPath & $xmlerr)
	SetError(1)
	Return -1
	;	EndIf
EndFunc   ;==>_XMLGetAttrib

;===============================================================================
; Function Name:	_XMLSetAttrib
; Description:		Set XML Field(s) based on XPath input from root node.
; Parameters:		$path xml tree path from root node (root/child/child..)
;					$attrib  the attribute to set.
;					$value the value to give the attribute defaults to ""
; Syntax:			_XMLSetAttrib($path,$attrib,$value)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of fields text values
;					on error returns -1 and sets error to 1
;===============================================================================
Func _XMLSetAttrib($strXPath, $strAttrib, $strValue = "")
	Local $objNodeList, $arrResponse[1], $i
	
	$objNodeList = $objDoc.documentElement.getElementsByTagName ($strXPath)
	_DebugWrite(" Node list Length: " & $objNodeList.length)
	;		If @error = 0 Then
	While @error = 0 And $objNodeList.length > 0
		;		If $objNodeList.length <> 0 Then
		ReDim $arrResponse[$objNodeList.length]
		For $i = 0 To $objNodeList.length - 1
			$arrResponse[$i] = $objNodeList.item ($i).SetAttribute ($strAttrib, $strValue)
		Next
		$objDoc.save ($strFile)
		Return $arrResponse
		;			Else
	WEnd
	;	_XMLError( "Failed to set attribute for: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error failed to set attribute for: " & $strXPath & @CRLF)
	SetError(1)
	Return -1
	;		EndIf
EndFunc   ;==>_XMLSetAttrib

;===============================================================================
; Function Name:	_XMLGetAllAttrib
; Description:		Get all XML Field(s) attributes based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
;					$query the query string in xml format
;					$names the array to return the attrib names
;					$value the array to return the attrib values
;					[$query] DOM compliant query string  (not really necessary as it becomes
;part of the path
; Syntax:			_XMLGetAllAttrib($path,$query)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of fields text values
;					on error set error to 1 and returns -1
;===============================================================================
Func _XMLGetAllAttrib($strXPath, ByRef $aName, ByRef $aValue, $strQry = "")
	Local $objNodeList, $objQueryNodes, $objNode, $arrResponse[2][1], $i
	
	$objQueryNodes = $objDoc.documentElement.selectNodes ($strXPath & $strQry)
	While @error = 0 And $objQueryNodes.length > 0
		For $objNode In $objQueryNodes
			;			$objNodeList = $objDoc.documentElement.selectSingleNode ($strXPath & $strQry).attributes
			$objNodeList = $objNode.attributes
			if ($objNodeList.length) Then
				_DebugWrite("Get all attrib " & $objNodeList.length)
				ReDim $arrResponse[2][$objNodeList.length + 1]
				ReDim $aName[$objNodeList.length]
				ReDim $aValue[$objNodeList.length]
				For $i = 0 To $objNodeList.length - 1
					;					$arrResponse[0,$i] = $objNodeList.item ($i).nodeName & "," & $objNodeList.item ($i).Text
					$arrResponse[0][$i] = $objNodeList.item ($i).nodeName
					$arrResponse[1][$i] = $objNodeList.item ($i).Value
					$aName[$i] = $objNodeList.item ($i).nodeName
					$aValue[$i] = $objNodeList.item ($i).Value
				Next
				;				Return $arrResponse
			Else
				ExitLoop
			EndIf
		Next
		Return $arrResponse
	WEnd
	;	_XMLError( "Error retrieving attributes for: " & $strXPath & @CRLF & $oMyError.windescription & @CRLF & $oMyError.scriptline)
	_XMLError( "Error retrieving attributes for: " & $strXPath & @CRLF)
	SetError(1)
	Return -1
	;	EndIf
EndFunc   ;==>_XMLGetAllAttrib

;===============================================================================
; Function Name:	_XMLUpdateField
; Description:		Update existing node(s) based on XPath specs.
; Parameters:		$path	Path from root node
;					$new_data	Data to update node with
; Syntax:			_XMLUpdateField($path,$new_data)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			on error set error to 1 and returns -1
;===============================================================================
Func _XMLUpdateField($strXPath, $strData)
	Local $objField, $objNodeList
	While @error = 0
		$objNodeList = $objDoc.documentElement.selectNodes ($strXPath)
		;	If $objDoc.documentElement.selectNodes ($strXPath) Then
		For $objField In $objNodeList
			$objField.Text = $strData
		Next
		$objDoc.Save ($strFile)
		$objField = ""
		Return
	WEnd
	
	;	Else
	;		_XMLError( "Failed to update field for: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Failed to update field for: " & $strXPath & @CRLF)
	SetError(1)
	Return -1
	;	EndIf
EndFunc   ;==>_XMLUpdateField

;===============================================================================
; Function Name:	_XMLCreateCDATA
; Description:		Create a CDATA SECTION node directly under root.
; Parameters:		$node name of node to create
;					$data CDATA value
; Syntax:			_XMLCreateCDATA($node,$data)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			on error set error to 1 and returns -1
;===============================================================================
Func _XMLCreateCDATA($strNode, $strCDATA)
	Local $objChild, $objNode
	While @error = 0
		$objNode = $objDoc.documentElement.selectSingleNode ($strNode)
		$objChild = $objDoc.createCDATASection ($strCDATA)
		$objNode.insertBefore ($objChild, $objNode.childNodes (0))
		;		$objNode.appendChild($objChild)
		$objDoc.Save ($strFile)
		$objChild = ""
		Return
	WEnd
	;	_XMLError( "Failed to create CDATA Section: " & $strNode & @CRLF & $oMyError.windescription)
	_XMLError( "Failed to create CDATA Section: " & $strNode & @CRLF)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLCreateCDATA

;===============================================================================
; Function Name:	_XMLCreateComment
; Description:		Create a COMMENT node at specified path.
; Parameters:		$node	name of node to create
;					$comment the comment to add the to the xml file
; Syntax:			_XMLCreateComment($node,$comment)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			on error set error to 1 and returns -1
;===============================================================================
Func _XMLCreateComment($strNode, $strComment)
	Local $objChild, $objNode, $objRoot
	While @error = 0
		$objNode = $objDoc.documentElement.selectSingleNode ($strNode)
		;$objNode = $objDoc.selectSingleNode($strNode)
		$objChild = $objDoc.createComment ($strComment)
		$objNode.insertBefore ($objChild, $objNode.childNodes (0))
		;		$objNode.appendChild($objChild)
		$objDoc.Save ($strFile)
		$objChild = ""
		Return
	WEnd
	;	_XMLError( "Failed to root child: " & $strNode & @CRLF & $oMyError.windescription)
	_XMLError( "Failed to root child: " & $strNode & @CRLF)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLCreateComment

;===============================================================================
; Function Name:	_XMLCreateRootChild
; Description:		Create node directly under root.
; Parameters:		$node	name of node to create
;					$value optional value to create
; Syntax:			_XMLCreateRootChild($node,[$value])
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			on error set error to 1 and returns -1
;===============================================================================
Func _XMLCreateRootChild($strNode, $strData = "")
	Local $objChild
	$objChild = $objDoc.createNode (1, $strNode, "")
	If $strData <> "" Then $objChild.text = $strData
	While @error = 0
		$objDoc.documentElement.appendChild ($objChild)
		
		$objDoc.Save ($strFile)
		$objChild = ""
		Return
	WEnd
	;	_XMLError( "Failed to root child: " & $strNode & @CRLF & $oMyError.windescription)
	_XMLError( "Failed to root child: " & $strNode & @CRLF)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLCreateRootChild

;===============================================================================
; Function Name:	_XMLCreateRootNodeWAttr
; Description:		Create a child node under root node with attributes.
; Parameters:		$node  node to add with attibute(s)
;					$[array]attrib  attribute name(s) -- can be array
;					$[array]value	attribute value(s) -- can be array
;					$data 	optional value to give the node.
; Requirements		This function requires that each attribute name has
;					a corresponding value.
; Syntax:			_XMLCreateRootNodeWAttr($node,$array_attribs,$array_value)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			on error set error to 1 or 2 and returns -1
;===============================================================================
Func _XMLCreateRootNodeWAttr($strNode, $aAttr, $aVal, $strData = "")
	Local $objChild, $objAttr, $objAttrVal
	$objChild = $objDoc.createNode (1, $strNode, "")
	If $strData <> "" Then $objChild.text = $strData
	;	If @error = 0 Then
	While @error = 0
		If IsArray($aAttr) And IsArray($aVal) Then
			;If UBound($aAttr)-LBound($aAttr) <> UBound($aVal)-LBound($aVal) Then  ; no lbound support??
			If UBound($aAttr) <> UBound($aVal) Then
				_XMLError( "Attribute and value mismatch" & @CRLF & "Please make sure each attribute has a matching value.")
				SetError(2)
				Return -1
			Else
				Local $i
				;For $i = LBound($aAttr) To UBound($aAttr); no lbound support??
				For $i = 0 To UBound($aAttr) - 1
					If $aAttr[$i] = "" Then
						_XMLError( "Error creating child node: " & $strNode & @CRLF & " Attribute Name Cannot be NULL." & @CRLF)
						SetError(1)
						Return -1
					EndIf
;~ 						if $aVal[$i] = chr(0) Then
;~ 							_XMLError( "Error creating child node: " & $strNode & @CRLF &" Attribute Value Cannot be NULL." & @CRLF)
;~ 							Seterror(1)
;~ 							Return -1
;~ 						EndIf
					
					$objAttr = $objDoc.createAttribute ($aAttr[$i])
					$objAttrVal = $objDoc.createTextNode ($aVal[$i])
					$objAttr.appendChild ($objAttrVal)
					$objChild.SetAttribute ($aAttr[$i], $aVal[$i])
				Next
			EndIf
		Else
			$objAttr = $objDoc.createAttribute ($aAttr)
			$objAttrVal = $objDoc.createTextNode ($aVal)
			$objAttr.appendChild ($objAttrVal)
			$objChild.SetAttribute ($aAttr, $aVal)
		EndIf
		$objDoc.documentElement.appendChild ($objChild)
		$objDoc.Save ($strFile)
		$objChild = ""
		Return
		;	Else
	WEnd
	;	_XMLError( "Failed to create root child with attributes: " & $strNode & @CRLF & $oMyError.windescription)
	_XMLError( "Failed to create root child with attributes: " & $strNode & @CRLF)
	SetError(1)
	Return -1
	;	EndIf
EndFunc   ;==>_XMLCreateRootNodeWAttr

;===============================================================================
; Function Name:	_XMLCreateChildNode
; Description:		Create a child node under the specified XPath Node.
; Parameters:		$path	Path from root
;					$node	Node to add
; Syntax:			_XMLCreateChildNode($path,$node)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			on error set error to 1 and returns -1
;===============================================================================
Func _XMLCreateChildNode($strXPath, $strNode, $strData = "")
	Local $objParent, $objChild, $objNodeList
	While @error = 0
		$objNodeList = $objDoc.documentElement.selectNodes ($strXPath)
		If IsObj($objNodeList) Then ;.length <> 0 Then
			;			For $objParent In $objNodeList.documentElement.selectNodes ($strXPath)
			For $objParent In $objNodeList
				$objChild = $objDoc.createNode (1, $strNode, "")
				If $strData <> "" Then $objChild.text = $strData
				$objParent.appendChild ($objChild)
			Next
			$objDoc.Save ($strFile)
			$objParent = ""
			$objChild = ""
			Return
		Else
			ExitLoop
		EndIf
	WEnd
	;	_XMLError( "Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF & $oMyError.windescription)
	_XMLError( "Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLCreateChildNode

;===============================================================================
; Function Name:	_XMLCreateChildNodeWAttr
; Description:		Create a child node(s) under the specified XPath Node with attributes.
; Parameters:		$sPath Path from root
; 					$sNode  node to add with attibute(s)
;					$[array]attrib  attribute name(s) -- can be array
;					$[array]value	attribute value(s) -- can be array
;					$data 			Optional value to give the child node.
; Requirements		This function requires that each attribute name has
;					a corresponding value.
; Syntax:			_XMLCreateChildNodeWAttr($path,$node,$[array]attrib,$]array]value)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			0 on error and set error 1 or 2
;===============================================================================
Func _XMLCreateChildNodeWAttr($strXPath, $strNode, $aAttr, $aVal, $strData = "")
	Local $objParent, $objChild, $objAttr, $objAttrVal
	While @error = 0
		$objNodeList = $objDoc.documentElement.selectNodes ($strXPath)
		If IsObj($objNodeList) Then
			;		For $objParent In $objDoc.documentElement.selectNodes ($strXPath)
			For $objParent In $objNodeList
				$objChild = $objDoc.createNode (1, $strNode, "")
				If $strData <> "" Then $objChild.text = $strData
				If IsArray($aAttr) And IsArray($aVal) Then
					If UBound($aAttr) <> UBound($aVal) Then
						_XMLError( "Attribute and value mismatch" & @CRLF & "Please make sure each attribute has a matching value.")
						SetError(2)
						Return -1
					Else
						Local $i
						;For $i = LBound($aAttr) To UBound($aAttr)	; no lbound support??
						For $i = 0 To UBound($aAttr) - 1
							If $aAttr[$i] = "" Then
								_XMLError( "Error creating child node: " & $strNode & @CRLF & " Attribute Name Cannot be NULL." & @CRLF)
								SetError(1)
								Return -1
							EndIf
;~ 						if $aVal[$i] = chr(0) Then
;~ 							_XMLError( "Error creating child node: " & $strNode & @CRLF & " Attribute Value Cannot be NULL." & @CRLF)
;~ 							;Seterror(1)
;~ 							Return -1
;~ 						EndIf
							$objAttr = $objDoc.createAttribute ($aAttr[$i])
							$objAttrVal = $objDoc.createTextNode ($aVal[$i])
							$objAttr.appendChild ($objAttrVal)
							$objChild.SetAttribute ($aAttr[$i], $aVal[$i])
							If @error <> 0 Then
								_XMLError( "Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF)
								;XMLError( "Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF & $oMyError.windescription)
								SetError(1)
								Return -1
							EndIf
						Next
					EndIf
				Else
					$objAttr = $objDoc.createAttribute ($aAttr)
					$objAttrVal = $objDoc.createTextNode ($aVal)
					$objAttr.appendChild ($objAttrVal)
					$objChild.SetAttribute ($aAttr, $aVal)
				EndIf
				$objParent.appendChild ($objChild)
			Next
			$objDoc.Save ($strFile)
			$objParent = ""
			$objChild = ""
			Return
		EndIf
	WEnd
	;	_XMLError( "Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF & $oMyError.windescription)
	_XMLError( "Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF)
	SetError(1)
	Return -1
	
EndFunc   ;==>_XMLCreateChildNodeWAttr

;===============================================================================
; Function Name:	_XMLError
; Description:		Sets error message generated by XML functs.
;					or Gets the message that was Set.
; Parameters:		$sError Node from root to delete
; Syntax:			_XMLError([$sError)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			Nothing or Error message
;===============================================================================
Func _XMLError($sError = "")
	If $sError = "" Then
		$sError = $sXML_error
		$sXML_error = ""
		Return $sError
	Else
		$sXML_error = $sError
	EndIf
	_DebugWrite($sXML_error)
EndFunc   ;==>_XMLError

;===============================================================================
; Function Name:	_COMerr
; Description:		Displays a message box with the COM Error.
; Parameters:		none
; Syntax:			_COMerr()
; Author(s):		SvenP 's  error handler
; Returns:
; From the forum this came.
;===============================================================================
Func _COMerr($quiet = "")
	;===============================================================================
	;added silent switch to allow the func returned to the option to display custom
	;error messages
	If $quiet = True Or $quiet = False Then
		$COMErr_Silent = $quiet
		$quiet = ""
		Return
	EndIf
	;===============================================================================
	If $COMErr_Silent <> True Then
		
		;	ConsoleWrite("COM Error")
		$HexNumber = Hex($oMyError.number, 8)
		
		MsgBox(0, @AutoItExe, "COM Error with DOM!" & @CRLF & @CRLF & _
				"err.description is: " & @TAB & $oMyError.description & @CRLF & _
				"err.windescription:" & @TAB & $oMyError.windescription & @CRLF & _
				"err.number is: " & @TAB & $HexNumber & @CRLF & _
				"err.lastdllerror is: " & @TAB & $oMyError.lastdllerror & @CRLF & _
				"err.scriptline is: " & @TAB & $oMyError.scriptline & @CRLF & _
				"err.source is: " & @TAB & $oMyError.source & @CRLF & _
				"err.helpfile is: " & @TAB & $oMyError.helpfile & @CRLF & _
				"err.helpcontext is: " & @TAB & $oMyError.helpcontext _
				)
		SetError(1) ; to check for after this function returns
		;	MsgBox(4096, "COM Error", "There is a COM Error")
	EndIf
EndFunc   ;==>_COMerr

; simple helper functions
;===============================================================================
; Function Name:	- 	_DebugWrite($message)
; Description:		-  Writes a message to console with a crlf on the end
; Parameters:		- $message   the message to display
; Syntax:			- _DebugWrite($message)
; Author(s):		-
; Returns:			-
;===============================================================================
Func _DebugWrite($message)
	If $debugging Then
		ConsoleWrite($message & @LF)
	EndIf
EndFunc   ;==>_DebugWrite

;===============================================================================
; Function Name:	_Notifier($Notifier_msg)
; Description:		displays a simple "ok" messagebox
; Parameters:		$Notifier_Msg   The message to display
; Syntax:			_Notifier($Notifier_msg)
; Author(s):		-
; Returns:			-
;===============================================================================
Func _Notifier($Notifier_msg)
	Return	msgbox (4096, @ScriptName, $Notifier_msg)
EndFunc   ;==>_Notifier
;===============================================================================
; Function Name:	- 	_SetDebug($flag =False)
; Description:		-  Writes a message to console with a crlf on the end
; Parameters:		- $message   the message to display
; Syntax:			- _DebugWrite($message)
; Author(s):		-
; Returns:			-
;===============================================================================
Func _SetDebug($debug_flag = True)
	$debugging = $debug_flag
EndFunc   ;==>_SetDebug
