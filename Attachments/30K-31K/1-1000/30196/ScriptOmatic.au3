#AutoIt3Wrapper_Au3Check_Parameters= -d -w 1 -w 2 -w 3 -w 4 -w 5 -w 6
; AutoIt ScriptOMatic
; -------------------
;
; AutoIt's counterpart of Microsoft's Scriptomatic
;
; Author:		SvenP
; Date/version:	2005-04-17
; See also:		http://www.microsoft.com/technet/scriptcenter/tools/scripto2.mspx
; Requires:		AutoIt beta version 3.1.1.8 or higher (COM support!!)
;
; GUI generated by AutoBuilder 0.5 Prototype
;
; Updated by Tlem (2010-04-05)
;		- Compatibility with 3.3.0.0+
;		- Add #RequireAdmin for new Windows compatibility (admin right for Vista and Seven)
;		- Declaration of all variables (use of #AutoIt3Wrapper_Au3Check_Parameters= -d -w 1 -w 2 -w 3 -w 4 -w 5 -w 6 parameter)
;		- Fix the bug of multiple instance of ScriptOMatic when compiled (ChrisL)
;		- Fix problem with the error on that you must select 2 times the same namespace to have correct WMI classes.
;		- Fix the error : $objClass = $objWMIService.Get($strSelectedClass)^ ERROR if you chose another namespace with wrong WMI classe.
;		- Somes little GUI modifications to disable and enable controls when it is needed.
;		- Improuvement of somes controls and some other stuf on GUI and controls ...
;		- Add buzy cursor when the script is busy. ;)
;		- Add language translation (French)

#RequireAdmin
#include <GuiConstants.au3>
#include <GUIConstantsEx.au3>
#include <WindowsConstants.au3>

;************************
;* Global State Variables
;************************
Global $strAppTitle, $strCtrlWMINameSpace, $strCtrlWMIClass, $strCtrlRun, $strCtrlOpen, $strCtrlSave
Global $strCtrlQuit, $strCtrlOutput, $strCtrlDialog, $strCtrlText, $strCtrlHTML, $strWait, $strClassHelpTip
Global $strWaitNamespaces, $strWMIWaitMsg, $strSelectWmiClass, $NoDynamiqueClass, $ClassError, $GeneratedBy
Global $SetWMI_RS, $CompWMI_Rs, $HtmlOutput, $TitleWMIOutput, $strWMIOutput, $SaveScript, $strProperty, $StrValue
Global $msg, $szFlag, $StrMessage, $NoDynamiqueClassError = 0
Global $g_strCurrentNamespace = "\root\CIMV2"
Global $g_iCurrentNamespaceIndex = 0
Global $g_strWMISource = "localhost"
Global $g_strOutputFormat = "Dialog"

;************************
;* Language selection
;************************
If StringInStr("040c, 080c, 0c0c, 100c, 140c, 180c", @OSLang) Then
	_French()
Else
	_English()
EndIf

;************************
;* Main GUI
;************************
Global $GUI_Main = GUICreate($strAppTitle, 684, 561, (@DesktopWidth - 684) / 2, (@DesktopHeight - 561) / 2)

Global $GUI_AST_MainGroup = GUICtrlCreateGroup("", 10, 10, 660, 530)
Global $GUI_WMI_NamespaceLabel = GUICtrlCreateLabel($strCtrlWMINameSpace, 20, 30, 150, 20)
Global $GUI_WMI_Namespace = GUICtrlCreateCombo("WMI_Namespaces", 20, 50, 280, 80, BitOR(0x1, 0x2, 0x40, 0x00200000)) ; BitOR($GUI_SS_DEFAULT_COMBO,$CBS_SIMPLE))
Global $GUI_WMI_ClassLabel = GUICtrlCreateLabel($strCtrlWMIClass, 320, 30, 240, 20)
Global $GUI_WMI_Classes = GUICtrlCreateCombo("WMI_Classes", 320, 50, 340, 80, BitOR(0x1, 0x2, 0x40, 0x00200000)) ; BitOR($GUI_SS_DEFAULT_COMBO,$CBS_SIMPLE))
Global $GUI_AST_ButtonGroup = GUICtrlCreateGroup("", 10, 80, 660, 50)
Global $GUI_WMI_ClassHelp = GUICtrlCreateIcon(@SystemDir & "\shell32.dll", -211, 635, 18, 32, 32)
GUICtrlSetTip(-1, $strClassHelpTip)
Global $GUI_AST_Run = GUICtrlCreateButton($strCtrlRun, 20, 100, 50, 20)
Global $GUI_AST_CIMv2 = GUICtrlCreateButton("CIMv2", 80, 100, 50, 20)
Global $GUI_AST_WMISource = GUICtrlCreateButton("WMISource", 140, 100, 70, 20)
Global $GUI_AST_Open = GUICtrlCreateButton($strCtrlOpen, 220, 100, 60, 20)
Global $GUI_AST_Save = GUICtrlCreateButton($strCtrlSave, 290, 100, 60, 20)
Global $GUI_AST_Quit = GUICtrlCreateButton($strCtrlQuit, 360, 100, 60, 20)
Global $GUI_AST_OptionGroup = GUICtrlCreateGroup($strCtrlOutput, 430, 80, 240, 50)
Global $GUI_AST_RadioDialog = GUICtrlCreateRadio($strCtrlDialog, 440, 100, 60, 20)
Global $GUI_AST_RadioText = GUICtrlCreateRadio($strCtrlText, 510, 100, 50, 20)
Global $GUI_AST_RadioHTML = GUICtrlCreateRadio($strCtrlHTML, 570, 100, 50, 20)
Global $GUI_AST_ScriptCode = GUICtrlCreateEdit($strWait, 20, 140, 640, 390)

GUISetState()

; Initial GUI Settings
GUICtrlSetState($GUI_AST_RadioDialog, $GUI_CHECKED)
GuiWait(1, $strWait & @CRLF & $strWaitNamespaces)

; Fill the WMI_Namespaces Combobox
LoadWMINamespaces()

; Fill the WMI_Classes Combobox
HandleNamespaceChange()

While 1
	$msg = GUIGetMsg()
	Switch $msg

		Case $GUI_EVENT_CLOSE
			ExitLoop

		Case $GUI_AST_Quit
			ExitLoop

		Case $GUI_WMI_Namespace
			GuiWait(1, $strWait)
			HandleNameSpaceChange()

		Case $GUI_WMI_Classes
			ComposeCode()

		Case $GUI_WMI_ClassHelp
			ShellExecute("http://msdn.microsoft.com/en-us/library/aa394554%28v=VS.85%29.aspx")

		Case $GUI_AST_Run
			RunScript()

		Case $GUI_AST_Save
			SaveScript()

		Case $GUI_AST_Open
			OpenScript()

		Case $GUI_AST_CIMv2
			GUICtrlSetData($GUI_AST_ScriptCode, $strWait)
			SetNamespaceToCIMV2()
			HandleNameSpaceChange()

		Case $GUI_AST_WMISource
			SetWMIRepository()
			GUICtrlSetData($GUI_AST_ScriptCode, $strWait)
			HandleNamespaceChange()

		Case $GUI_AST_RadioDialog Or $GUI_AST_RadioText Or $GUI_AST_RadioHTML
			HandleOutputChange()

	EndSwitch
WEnd

GUIDelete()
Exit

;********************************************************************
;* LoadWMINamespaces
;********************************************************************
Func LoadWMINamespaces()

	Local $strCsvListOfNamespaces = ""
	Local $strNameSpacesCombo = ""

	;GUICtrlSetData($GUI_WMI_Namespace, $strWaitNamespaces, $strWaitNamespaces)
	GUICtrlSetData($GUI_AST_ScriptCode, "", "")
	GUICtrlSetData($GUI_AST_ScriptCode, $strWait & @CRLF & $strWaitNamespaces)

	EnumNameSpaces("root", $strCsvListOfNamespaces)

	Local $arrNamespaces = StringSplit($strCsvListOfNamespaces, ",")

	For $strNamespace In $arrNamespaces
		$strNameSpacesCombo = $strNameSpacesCombo & "|" & $strNamespace
	Next

	GUICtrlSetData($GUI_WMI_Namespace, $strNameSpacesCombo, "ROOT\CIMV2")
	If GUICtrlRead($GUI_WMI_Namespace) = "" Then GUICtrlSetData($GUI_WMI_Classes, "", "")

EndFunc   ;==>LoadWMINamespaces

;********************************************************************
;* EnumNamespaces
;********************************************************************
Func EnumNamespaces($strNamespace, ByRef $tmpCsvListOfNamespaces)

	If $tmpCsvListOfNamespaces = "" Then
		$tmpCsvListOfNamespaces = $strNamespace
	Else
		$tmpCsvListOfNamespaces = $tmpCsvListOfNamespaces & "," & $strNamespace
	EndIf

	Local $objWMIService = ObjGet("winmgmts:\\" & $g_strWMISource & "\" & $strNamespace)

	If Not @error Then

		Local $colNameSpaces = $objWMIService.InstancesOf("__NAMESPACE")

		For $objNameSpace In $colNameSpaces
			EnumNamespaces($strNamespace & "\" & $objNameSpace.Name, $tmpCsvListOfNamespaces)
		Next
	Else
		$tmpCsvListOfNamespaces = ""
	EndIf

EndFunc   ;==>EnumNamespaces

;********************************************************************
;* HandleNamespaceChange
;********************************************************************
Func HandleNamespaceChange()

	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	; Clear the WMI classes pulldown location.
	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	Local $strSelectedNamespace = GUICtrlRead($GUI_WMI_Namespace)

	; Disable the controls until class load has been completed
	;$strWMIWaitMsg &= $strSelectedNamespace
	;GUICtrlSetData($GUI_WMI_Classes, $strWMIWaitMsg, $strWMIWaitMsg)
	GuiWait(1, GUICtrlRead($GUI_AST_ScriptCode) & @CRLF & $strWMIWaitMsg & $strSelectedNamespace)

	$g_strCurrentNamespace = "\" & $strSelectedNamespace
	LoadWMIClasses()

	GuiWait(0, "")

EndFunc   ;==>HandleNamespaceChange

;********************************************************************
;* LoadWMIClasses
;*
;* Fetch all the classes in the currently selected namespace, and
;* populate the keys of a dictionary object with the names of all
;* dynamic (non-association) classes. Then we transfer the keys to
;* an array, sort the array, and finally use the sorted array to
;* populate the WMI classes pulldown.
;********************************************************************
Func LoadWMIClasses()

	Const $SORT_KEYS = 1
	;Const $SORT_ITEMS = 2

	Local $objClassDictionary = ObjCreate("Scripting.Dictionary")
	Local $objQualifierDictionary = ObjCreate("Scripting.Dictionary")

	Local $strComputer = "."
	Local $objWMIService = ObjGet("winmgmts:\\" & $strComputer & $g_strCurrentNamespace)

	If Not @error Then

		For $objClass In $objWMIService.SubclassesOf()

			For $objQualifier In $objClass.Qualifiers_() ; Dummy (), because it ends with an underscore !
				$objQualifierDictionary.Add(StringLower($objQualifier.Name), "")
			Next

			If $objQualifierDictionary.Exists("dynamic") Then

				;$TempVar = $objClass.Path_.Class
				;$objClassDictionary.Add($TempVar, "")	; Can't use object in arguments ?!!

				$objClassDictionary.Add($objClass.Path_.Class, "")

			EndIf

			$objQualifierDictionary.RemoveAll

		Next

		$objQualifierDictionary = ""

		;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; If the current namespace contains dynamic classes...
		;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		If $objClassDictionary.Count Then

			;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
			; Sort the dictionary.
			;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
			SortDictionary($objClassDictionary, $SORT_KEYS)

			;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
			; Populate the WMI classes pulldown with the sorted dictionary.
			;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

			Local $strClassesCombo = "|" & $strSelectWmiClass

			For $strWMIClass In $objClassDictionary ;  method .Keys is not an object ??
				$strClassesCombo = $strClassesCombo & "|" & $strWMIClass
			Next

			GUICtrlSetData($GUI_WMI_Classes, $strClassesCombo, $strSelectWmiClass)

		EndIf
	EndIf

	If @error Or $objClassDictionary.Count = 0 Then
		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; And if the current namespace doesn't contain dynamic classes.
		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		;GUICtrlSetData($GUI_WMI_Classes, $NoDynamiqueClass, "")
		$NoDynamiqueClassError = 1
	EndIf

	$objClassDictionary = ""

EndFunc   ;==>LoadWMIClasses

;********************************************************************
;* SortDictionary
;*
;* Shell sort based on:
;* http://support.microsoft.com/support/kb/articles/q246/0/67.asp
;********************************************************************
Func SortDictionary(ByRef $objDict, $intSort)

	Const $dictKey = 1
	Const $dictItem = 2

	Local $strDict[1][3]

	Local $intCount = $objDict.Count

	If $intCount > 1 Then

		ReDim $strDict[$intCount][3]

		Local $i = 0
		For $objKey In $objDict

			$strDict[$i][$dictKey] = String($objKey)
			$strDict[$i][$dictItem] = String($objDict($objKey))

			$i = $i + 1
		Next

		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; Perform a shell sort of the 2D string array
		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		For $i = 0 To ($intCount - 2)
			For $j = $i To ($intCount - 1)
				If $strDict[$i][$intSort] > $strDict[$j][$intSort] Then
					Local $strKey = $strDict[$i][$dictKey]
					Local $strItem = $strDict[$i][$dictItem]
					$strDict[$i][$dictKey] = $strDict[$j][$dictKey]
					$strDict[$i][$dictItem] = $strDict[$j][$dictItem]
					$strDict[$j][$dictKey] = $strKey
					$strDict[$j][$dictItem] = $strItem
				EndIf
			Next
		Next

		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; Erase the contents of the dictionary object
		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		$objDict.RemoveAll

		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; Repopulate the dictionary with the sorted information
		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		For $i = 0 To ($intCount - 1)
			$objDict.Add($strDict[$i][$dictKey], $strDict[$i][$dictItem])
		Next

	EndIf

EndFunc   ;==>SortDictionary

;********************************************************************
;* ComposeCode
;********************************************************************
Func ComposeCode()

	Local $objClass = ""

	Local $strSelectedClass = GUICtrlRead($GUI_WMI_Classes)
	; Check if a valid class has been selected
	If $strSelectedClass <> $strSelectWmiClass Then

		Local $bHasDates = False ; Flag: output has date fields
		Local $strHeaderStart = Chr(34)
		Local $strRowStart = Chr(34)
		Local $strColumnSeparator = ": "
		Local $strRowEnd = " & @CRLF"


		Local $strComputerCommand = "$strComputer = " & Chr(34) & $g_strWMISource & Chr(34)

		Local $objWMIService = ObjGet("winmgmts:{impersonationLevel=impersonate}!\\" & @ComputerName & $g_strCurrentNamespace)
		$objClass = $objWMIService.Get($strSelectedClass)

		If IsObj($objClass) Then

			Local $strScriptCode = ""
			$strScriptCode = $strScriptCode & $GeneratedBy & @CRLF & @CRLF
			$strScriptCode = $strScriptCode & "$wbemFlagReturnImmediately = 0x10" & @CRLF
			$strScriptCode = $strScriptCode & "$wbemFlagForwardOnly = 0x20" & @CRLF
			$strScriptCode = $strScriptCode & '$colItems = ""' & @CRLF
			$strScriptCode = $strScriptCode & $strComputerCommand & @CRLF & @CRLF
			$strScriptCode = $strScriptCode & '$OutputTitle = ""' & @CRLF
			$strScriptCode = $strScriptCode & '$Output = ""' & @CRLF

			If $g_strOutputFormat = "HTML" Then
				$strScriptCode = $strScriptCode & "$Output = $Output & '<html><head><title>" & $HtmlOutput & "</title></head><body> " & _
						"<style>table {font-size: 10pt; font-family: arial;} th {background-color: buttonface; font-decoration: bold;} " & _
						"</style><table BORDER=" & Chr(34) & "1" & Chr(34) & "><tr><th>" & $strProperty & "</th><th>" & $StrValue & "</th></tr>'" & @CRLF
				$strRowStart = Chr(34) & "<tr><td>"
				$strHeaderStart = "'<tr bgcolor=" & Chr(34) & "yellow" & Chr(34) & "><td>' & " & Chr(34)
				$strColumnSeparator = "</td><td>&nbsp;"
				$strRowEnd = " & " & Chr(34) & "</td></tr>" & Chr(34) & " & @CRLF"
			EndIf


			$strScriptCode = $strScriptCode & "$OutputTitle &= " & $strHeaderStart & "Computer" & $strColumnSeparator & Chr(34) & " & $strComputer " & $strRowEnd & @CRLF

			If $g_strOutputFormat = "Dialog" Then
				$strScriptCode = $strScriptCode & "$OutputTitle &= " & Chr(34) & "==========================================" & Chr(34) & $strRowEnd & @CRLF
			EndIf

			$strScriptCode = $strScriptCode & "$objWMIService = ObjGet(" & Chr(34) & "winmgmts:\\" & Chr(34) & " & $strComputer & " & Chr(34) & $g_strCurrentNamespace & Chr(34) & ")" & @CRLF
			$strScriptCode = $strScriptCode & "$colItems = $objWMIService.ExecQuery(" & Chr(34) & "SELECT * FROM " & $strSelectedClass & Chr(34) & ", " & Chr(34) & "WQL" & Chr(34) & ", _" & @CRLF
			$strScriptCode = $strScriptCode & "                                          $wbemFlagReturnImmediately + $wbemFlagForwardOnly)" & @CRLF & @CRLF
			$strScriptCode = $strScriptCode & "If IsObj($colItems) then" & @CRLF
			$strScriptCode = $strScriptCode & "   Local $Object_Flag = 0" & @CRLF

			$strScriptCode = $strScriptCode & "   For $objItem In $colItems" & @CRLF
			$strScriptCode = $strScriptCode & "      $Object_Flag = 1" & @CRLF

			For $objProperty In $objClass.Properties_() ; Must use (), because method ends with an underscore

				If $objProperty.IsArray = True Then
					$strScriptCode = $strScriptCode & "      $str" & $objProperty.Name & " = $objItem." & $objProperty.Name & "(0)" & @CRLF
					$strScriptCode = $strScriptCode & "      $Output &= " & $strRowStart & $objProperty.Name & $strColumnSeparator & Chr(34) & " & $str" & $objProperty.Name & $strRowEnd & @CRLF
				ElseIf $objProperty.CIMTYPE = 101 Then
					$bHasDates = True
					$strScriptCode = $strScriptCode & "      $Output &= " & $strRowStart & $objProperty.Name & $strColumnSeparator & Chr(34) & " & WMIDateStringToDate($objItem." & $objProperty.Name & ")" & $strRowEnd & @CRLF
				Else
					$strScriptCode = $strScriptCode & "      $Output &= " & $strRowStart & $objProperty.Name & $strColumnSeparator & Chr(34) & " & $objItem." & $objProperty.Name & $strRowEnd & @CRLF
				EndIf
			Next

			If $g_strOutputFormat = "Dialog" Then
				$strScriptCode = $strScriptCode & '      if Msgbox(1,"' & $TitleWMIOutput & '",$Output) = 2 then ExitLoop' & @CRLF
				$strScriptCode = $strScriptCode & '      $Output=""' & @CRLF
			EndIf
			$strScriptCode = $strScriptCode & '   Next' & @CRLF
			$strScriptCode = $strScriptCode & '  If $Object_Flag = 0 Then Msgbox(1,"' & $TitleWMIOutput & '",$OutputTitle)' & @CRLF

			If $g_strOutputFormat = "Text" Then
				$strScriptCode = $strScriptCode & '   ConsoleWrite($Output)' & @CRLF
				$strScriptCode = $strScriptCode & '   FileWrite(@TempDir & "\' & $strSelectedClass & '.TXT", $Output )' & @CRLF
				$strScriptCode = $strScriptCode & '   Run(@Comspec & " /c start " & @TempDir & "\' & $strSelectedClass & '.TXT" )' & @CRLF
			ElseIf $g_strOutputFormat = "HTML" Then
				$strScriptCode = $strScriptCode & '   FileWrite(@TempDir & "\' & $strSelectedClass & '.HTML", $Output )' & @CRLF
				$strScriptCode = $strScriptCode & '   Run(@Comspec & " /c start " & @TempDir & "\' & $strSelectedClass & '.HTML" )' & @CRLF
			EndIf

			$strScriptCode = $strScriptCode & "Else" & @CRLF
			$strScriptCode = $strScriptCode & '   Msgbox(0,"' & $TitleWMIOutput & '","' & $strWMIOutput & '" & ' & Chr(34) & $strSelectedClass & Chr(34) & ' )' & @CRLF

			$strScriptCode = $strScriptCode & "Endif" & @CRLF
			$strScriptCode = $strScriptCode & @CRLF & @CRLF

			If $bHasDates Then
				$strScriptCode = $strScriptCode & "Func WMIDateStringToDate($dtmDate)" & @CRLF
				$strScriptCode = $strScriptCode & Chr(9) & "Return (StringMid($dtmDate, 5, 2) & ""/"" & _" & @CRLF
				$strScriptCode = $strScriptCode & Chr(9) & "StringMid($dtmDate, 7, 2) & ""/"" & StringLeft($dtmDate, 4) _" & @CRLF
				$strScriptCode = $strScriptCode & Chr(9) & "& "" "" & StringMid($dtmDate, 9, 2) & "":"" & StringMid($dtmDate, 11, 2) & "":"" & StringMid($dtmDate,13, 2))" & @CRLF
				$strScriptCode = $strScriptCode & "EndFunc"
			EndIf
		Else
			$strScriptCode = $ClassError & $g_strCurrentNamespace & "\" & $strSelectedClass
		EndIf

		GUICtrlSetData($GUI_AST_ScriptCode, $strScriptCode)

		;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; Once the code is successfully composed and put into the
		; textarea, ensure that the run and save buttons are enabled.
		;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		GUICtrlSetState($GUI_AST_Run, $GUI_ENABLE)
		GUICtrlSetState($GUI_AST_Save, $GUI_ENABLE)

	Else
		; Disable Run and Save buttons, because no valid code has been generated
		GUICtrlSetState($GUI_AST_Run, $GUI_DISABLE)
		GUICtrlSetState($GUI_AST_Save, $GUI_DISABLE)
	EndIf

EndFunc   ;==>ComposeCode


;********************************************************************
;* RunScript
;********************************************************************
Func RunScript()

	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	; Create a temporary script file named "temp_script.au3".
	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Local $strTmpName = @TempDir & "\temp_script.au3"

	If FileExists($strTmpName) Then FileDelete($strTmpName)

	FileWrite($strTmpName, GUICtrlRead($GUI_AST_ScriptCode))

	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	; Start constructing the command line that will run the script...
	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	Local $strCmdLine = @AutoItExe & " /AutoIt3ExecuteScript " & $strTmpName ;  ChrisL Fix

	RunWait($strCmdLine)

	FileDelete($strTmpName)

EndFunc   ;==>RunScript

;********************************************************************
;* SaveScript
;********************************************************************
Func SaveScript()

	Local $strTmpName = FileSaveDialog($SaveScript, @DesktopDir, "AutoIt3 Scripts (*.au3)", 16, GUICtrlRead($GUI_WMI_Classes), $GUI_Main)

	If Not @error And $strTmpName <> "" Then
		If StringRight($strTmpName, 4) <> ".AU3" Then $strTmpName = $strTmpName & ".AU3"
		If FileExists($strTmpName) Then FileDelete($strTmpName)
		FileWrite($strTmpName, GUICtrlRead($GUI_AST_ScriptCode))
	EndIf

EndFunc   ;==>SaveScript


;********************************************************************
;* OpenScript
;********************************************************************

Func OpenScript()

	Local $strTmpName = FileOpenDialog("Open Script", @DesktopDir, "AutoIt3 Scripts (*.au3)", Default, "", $GUI_Main)

	If Not @error And $strTmpName <> "" Then
		If FileExists($strTmpName) Then
			GUICtrlSetData($GUI_AST_ScriptCode, FileRead($strTmpName, FileGetSize($strTmpName)))
		EndIf
	EndIf

EndFunc   ;==>OpenScript


;****************************************************************************
;* SetNamespaceToCIMV2
;****************************************************************************
Func SetNamespaceToCIMV2()
	If StringUpper(GUICtrlRead($GUI_WMI_Namespace)) <> "ROOT\CIMV2" Then
		GUICtrlSetData($GUI_WMI_Namespace, "ROOT\CIMV2", "ROOT\CIMV2")
		HandleNamespaceChange()
	EndIf
EndFunc   ;==>SetNamespaceToCIMV2

;****************************************************************************
;* SetWMIRepository
;****************************************************************************
Func SetWMIRepository()

	Local $strWMISourceName = InputBox($SetWMI_RS, $CompWMI_Rs, $g_strWMISource, Default, Default, Default, Default, Default, Default, $GUI_Main)
	If $strWMISourceName <> "" Then

		GuiWait(1, "")
		$g_strWMISource = StringStripWS($strWMISourceName, 1 + 2)
		;target_computers.Value = $g_strWMISource
		LoadWMINamespaces()
	EndIf
	GuiWait(0, "")
EndFunc   ;==>SetWMIRepository

;****************************************************************************
;* HandleOutputChange
;****************************************************************************
Func HandleOutputChange()

	Local $ChosenFormat = $g_strOutputFormat
	If GUICtrlRead($GUI_AST_RadioDialog) = $GUI_CHECKED Then $ChosenFormat = "Dialog"
	If GUICtrlRead($GUI_AST_RadioText) = $GUI_CHECKED Then $ChosenFormat = "Text"
	If GUICtrlRead($GUI_AST_RadioHTML) = $GUI_CHECKED Then $ChosenFormat = "HTML"
	If $ChosenFormat <> $g_strOutputFormat Then
		$g_strOutputFormat = $ChosenFormat
		ComposeCode()
	EndIf
EndFunc   ;==>HandleOutputChange

;****************************************************************************
;* GUI Wait/Active
;****************************************************************************
Func GuiWait($szFlag, $StrMessage)
	If $szFlag = 1 Then
		GUISetCursor(15, 1, $GUI_Main)
		GUICtrlSetState($GUI_WMI_Namespace, $GUI_DISABLE)
		GUICtrlSetState($GUI_WMI_Classes, $GUI_DISABLE)
		GUICtrlSetState($GUI_AST_Run, $GUI_DISABLE)
		GUICtrlSetState($GUI_AST_CIMv2, $GUI_DISABLE)
		GUICtrlSetState($GUI_AST_WMISource, $GUI_DISABLE)
		GUICtrlSetState($GUI_AST_Open, $GUI_DISABLE)
		GUICtrlSetState($GUI_AST_Save, $GUI_DISABLE)
		GUICtrlSetState($GUI_AST_Quit, $GUI_DISABLE)

		GUICtrlSetData($GUI_AST_ScriptCode, "", "")
		GUICtrlSetData($GUI_AST_ScriptCode, $StrMessage)
	Else
		;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; Clear the code textarea and disable run and save.
		;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		GUICtrlSetData($GUI_AST_ScriptCode, "", $StrMessage)

		GUICtrlSetState($GUI_WMI_Classes, $GUI_ENABLE)
		GUICtrlSetState($GUI_WMI_Namespace, $GUI_ENABLE)
		GUICtrlSetState($GUI_AST_CIMv2, $GUI_ENABLE)
		GUICtrlSetState($GUI_AST_WMISource, $GUI_ENABLE)
		GUICtrlSetState($GUI_AST_Open, $GUI_ENABLE)
		GUICtrlSetState($GUI_AST_Quit, $GUI_ENABLE)
		GUISetCursor(2, 1, $GUI_Main)
	EndIf

	If $NoDynamiqueClassError = 1 Then
		GUICtrlSetData($GUI_WMI_Classes, "", "")
		GUICtrlSetData($GUI_AST_ScriptCode, $NoDynamiqueClass, "")
		$NoDynamiqueClassError = 0
	EndIf
EndFunc   ;==>GuiWait

;****************************************************************************
;* Set English language
;****************************************************************************
Func _English()
	$strAppTitle = "AutoIt ScriptOMatic Tool"
	$strCtrlWMINameSpace = "WMI Namespace"
	$strCtrlWMIClass = "WMI Class"
	$strCtrlRun = "Run"
	$strCtrlOpen = "Open"
	$strCtrlSave = "Save"
	$strCtrlQuit = "Quit"
	$strCtrlOutput = "Output"
	$strCtrlDialog = "Dialog"
	$strCtrlText = "Text"
	$strCtrlHTML = "HTML"
	$strWait = "One moment..."

	$strWaitNamespaces = "Please wait, Loading WMI Namespaces"
	$strWMIWaitMsg = "Please wait, trying to load WMI Classes in namespace "
	$strSelectWmiClass = "Select a WMI class"
	$strClassHelpTip = "WMI Classes on Microsoft site"
	$NoDynamiqueClass = "No dynamic classes found in current namespace." & @CRLF & "Select a different namespace."
	$ClassError = "Error: No Class properties found for "
	$GeneratedBy = "; Generated by AutoIt ScriptOMatic"
	$SetWMI_RS = "Set WMI Repository Source"
	$CompWMI_Rs = "Please enter the computer whose WMI repository you want to read from: "
	$HtmlOutput = "ScriptOMatic HTML Output"
	$TitleWMIOutput = "WMI Output"
	$strWMIOutput = "No WMI Objects Found for class: "
	$SaveScript = "Save Script"
	$strProperty = " Property "
	$StrValue = " Value "
EndFunc   ;==>_English

;****************************************************************************
;* Set French language
;****************************************************************************
Func _French()
	$strAppTitle = "Outil AutoIt ScriptOMatic"
	$strCtrlWMINameSpace = "Espaces de Nom WMI"
	$strCtrlWMIClass = "Classes WMI"
	$strCtrlRun = "Lancer"
	$strCtrlOpen = "Ouvrir"
	$strCtrlSave = "Sauver"
	$strCtrlQuit = "Quitter"
	$strCtrlOutput = "Sortie"
	$strCtrlDialog = "Dialogue"
	$strCtrlText = "Texte"
	$strCtrlHTML = "HTML"
	$strWait = "Veuillez patienter un moment SVP ..."

	$strWaitNamespaces = "Chargement des espaces de nom "
	$strWMIWaitMsg = "Chargement des Classes WMI dans l'espace de nom "
	$strSelectWmiClass = "Sélectionnez une Classe WMI"
	$strClassHelpTip = "WMI Classes sur le site Microsoft"
	$NoDynamiqueClass = "Aucune Classes dynamiques trouvée dans cet espace de nom." & @CRLF & "Sélectionnez un espace de nom différent."
	$ClassError = "Erreur : Aucune propriétés de Classe trouvée pour "
	$GeneratedBy = ";Généré par AutoIt ScriptOMatic"
	$SetWMI_RS = "Source de Dépôt WMI"
	$CompWMI_Rs = "Veuillez entrer le nom de l'ordinateur source de Dépôt WMI que vous voulez lire (localhost par défaut) : "
	$HtmlOutput = "Sortie ScriptOMatic HTML"
	$TitleWMIOutput = "Sortie WMI"
	$strWMIOutput = "Aucun objets WMI trouvés pour la Classe :"
	$SaveScript = "Sauver le script"
	$strProperty = " Propriété(s) "
	$StrValue = " Valeur(s) "
EndFunc   ;==>_French