#include <array.au3>


; Generated by AutoIt Scriptomatic May 31, 2009

$wbemFlagReturnImmediately = 0x10
$wbemFlagForwardOnly = 0x20
$colItems = ""
$strComputer = "localhost"

$Output = ""
$Output &= "==========================================" & @CRLF
$objWMIService = ObjGet("winmgmts:\\" & $strComputer & "\root\CIMV2")
$colItems = $objWMIService.ExecQuery("SELECT * FROM Win32_CDROMDrive", "WQL", _
		$wbemFlagReturnImmediately + $wbemFlagForwardOnly)

If IsObj($colItems) Then
	For $objItem In $colItems
		$Output &= "Availability: " & _Win32_CDRomDrive_AvailaibiltyDesc($objItem.Availability) & @CRLF
		$Output &= "Capabilities: " & _Win32_CDRomDrive_GetCapabilities($objItem, 1) & @CRLF
		$Output &= "Caption: " & $objItem.Caption & @CRLF
		$Output &= "Description: " & $objItem.Description & @CRLF
		$Output &= "Drive: " & $objItem.Drive & @CRLF
		$Output &= "MediaLoaded: " & _IsTrueOrFalse($objItem.MediaLoaded) & @CRLF
		$Output &= "==========================================" & @CRLF
		If MsgBox(1, "WMI Output", $Output) = 2 Then ExitLoop
		$Output = ""
	Next
Else
	MsgBox(0, "WMI Output", "No WMI Objects Found for class: " & "Win32_CDROMDrive")
EndIf





Func _Win32_CDRomDrive_AvailaibiltyDesc($AvailabilityID)
	; Author Rajesh V R
	; may 2009
	; gets the drive Availability description from uint value.
	Local $AvailabilityDesc[18] = ["Other", "Unknown", "Running or Full Power", "Warning", "In Test", "Not Applicable", "Power Off", "Off Line", "Off Duty", "Degraded", "Not Installed", "Install Error", "Power Save - Unknown", "Power Save - Low Power Mode", "Power Save - Standby", "Power Cycle", "Power Save - Warning"]
	Local $availDescription = ""
	For $i = 0 To 17
		If $AvailabilityID = $i+1 Then
			$availDescription = $AvailabilityDesc[$i]
			ExitLoop
		EndIf
	Next
	Return $availDescription
EndFunc   ;==>_Win32_CDRomDrive_AvailaibiltyDesc

Func _Win32_CDRomDrive_CapabilitiesDesc($CapabilityID)
	; Author Rajesh V R
	; may 2009
	; gets the drive capabilities description from uint values as inbuilt description string array is not so reliable.
	Local $CapDesc[13] = ["Unknown", "Other", "Sequential access", "Random access", "Writing", "Encryption", "Compression", "Removable media", "Manual cleaning", "Automatic cleaning", "SMART notification", "Dual-sided media", "Predismount eject not required"]
	Local $i, $capDescription = ""
	For $i = 0 To 12
		If $CapabilityID = $i Then
			$capDescription = $CapDesc[$i]
			ExitLoop
		EndIf
	Next
	Return $capDescription
EndFunc   ;==>_Win32_CDRomDrive_CapabilitiesDesc

Func _Win32_CDRomDrive_GetCapabilities($objItem, $returnType = 0)
	; Rajesh V R  may 2009
	; returns the capabilities of a  given optical drive object from wmi collection.
	; must input a valid CDROMDrive WMI Object only or else results would be unknown
	If IsObj($objItem) Then
		If $returnType = 0 Then ; array return type requested
			Local $Capabilities[2][1]
		Else ; csv type string return requested
			Local $Capabilities
		EndIf
		
		For $i = 0 To UBound($objItem.Capabilities)
			If $objItem.Capabilities($i) < 13 Then ; this is to skip some value 9237776 which is also appearing while looping, we arent concerned about it...
				If IsArray($Capabilities) Then ; returntype 0 return array
					ReDim $Capabilities[2][$i + 1]
					$Capabilities[0][$i] = $objItem.Capabilities($i)
					$Capabilities[1][$i] = _Win32_CDRomDrive_CapabilitiesDesc($objItem.Capabilities($i))
				Else ; returntype 1 return csv string
					If $i = 0 Then
						$Capabilities = $objItem.Capabilities($i) & "," & _Win32_CDRomDrive_CapabilitiesDesc($objItem.Capabilities($i))
					Else
						$Capabilities = $Capabilities & "," & $objItem.Capabilities($i) & "," & _Win32_CDRomDrive_CapabilitiesDesc($objItem.Capabilities($i))
					EndIf
				EndIf
				
			EndIf
		Next
		Return $Capabilities
	Else
		
		SetError(-1, "Input not an object", "")
		Msgbox(0,@error,"Error")
	EndIf
EndFunc   ;==>_Win32_CDRomDrive_GetCapabilities



Func _IsTrueOrFalse($BoolTag)
	; find out if it is a true value or false value returned!!!
	If $BoolTag = 0 Then
		Return False
	Else
		Return True
	EndIf
EndFunc   ;==>_TrueOrFalse



