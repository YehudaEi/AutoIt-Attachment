#AutoIt3Wrapper_UseX64=n ; Likely more codecs available for x86 version
#AutoIt3Wrapper_AU3Check_Parameters=-d -w 1 -w 2 -w 3 -w 4 -w 5 -w 6

; DIRECTSHOW PLAYER
;.......script written by trancexx (trancexx at yahoo dot com)

#include <GUIConstantsEx.au3>
#include <WindowsConstants.au3>
#include <WinApi.au3>
#include <GDIPlus.au3>
#include "AutoitObject.au3"

Opt("MustDeclareVars", 1)
Opt("WinWaitDelay", 0) ; 0 ms
Opt("GUIResizeMode", 576) ; $GUI_DOCKHEIGHT | $GUI_DOCKBOTTOM

HotKeySet("{ESC}", "_Quit") ; Esc to exit any time

Global $sMediaFile = $CmdLine[UBound($CmdLine) - 1] ; covering command line option

; Error monitoring
Global $oError = ObjEvent("AutoIt.Error", "_ErrFunc")

; Let the magic begin...
_AutoItObject_StartUp()

; DLLs to use
Global $oUSER32DLL = _AutoItObject_DllOpen("user32.dll")
Global $oSHELL32DLL = _AutoItObject_DllOpen("shell32.dll")
Global $oOLE32DLL = _AutoItObject_DllOpen("ole32.dll")
Global $oGDIPLUSDLL = _AutoItObject_DllOpen("gdiplus.dll")

; Jump list related
Global Const $PROGID = "AutoItObject.DirectShowPlayer.ProgID.1" ; generated by me
Global Const $APPID = "{4DA5FB3C-A693-40A6-AE69-5F55029EED9B}" ; generated by me
Global Const $EXTENSIONS = "flv;gif;bmp;jpg;wmv;avi;mpg;mp4;wmv;wma;mid;wav;mp3;rmi;aif;au;snd;kar"

_SetCurrentProcessExplicitAppUserModelID($APPID) ; this function is Win7 specific. It's used to group taskbar items of this ID.

; Jump list more
Global Const $WINDOWNAME = "{5A1289AB-BF24-44D5-9E55-BCC8E7207D10}" ; generated by me
If WinExists($WINDOWNAME) Then
	If $sMediaFile And $sMediaFile = "browse" Then
		$sMediaFile = FileOpenDialog("Choose fle", "", "(*.flv;*.gif;*.bmp;*.jpg;*.wmv;*.avi;*.mpg;*.mp4;*.wmv;*.wma;*.mid;*.wav;*.mp3;*.rmi;*.aif;*.au;*.snd;*.kar)|All files(*)", 1)
	EndIf
	If Not FileExists($sMediaFile) Then Exit
Else
	AutoItWinSetTitle($WINDOWNAME) ; unique name for the AutoIt window
	If $sMediaFile And $sMediaFile = "browse" Then $sMediaFile = FileOpenDialog("Choose fle", "", "(*.flv;*.gif;*.bmp;*.jpg;*.wmv;*.avi;*.mpg;*.mp4;*.wmv;*.wma;*.mid;*.wav;*.mp3;*.rmi;*.aif;*.au;*.snd;*.kar)|All files(*)", 1)
EndIf
Global $sGUID_WinMessage = "{27E93B42-F377-479C-8C8E-DF70FC9FCE34}" ; generated by me

_GDIPlus_Startup() ; for inline images

; Taskbar
Global Const $WM_TASKBUTT_CREATED = _WinAPI_RegisterWindowMessage("TaskbarButtonCreated") ; want to receive this message to know when to add aditional stuff.
Global Const $THBN_CLICKED = 0x1800

; GUI
Global $hGUI = GUICreate("DirectShow Player - AutoItObject", 578, 80, -1, -1, -1, $WS_EX_ACCEPTFILES)

Global $hVolSlider = GUICtrlCreateSlider(10, 14, 28, 64, 10 + 16)
GUICtrlSetTip(-1, "100 %VOL")
GUICtrlCreateLabel("VOL", 40, 21, 68, 20)
GUICtrlSetFont(-1, 9, -1, 2, "Curier New")

Global $hPosProgress = GUICtrlCreateProgress(71, 62, 428, 10, 1)

Global $hLabelPos = GUICtrlCreateLabel("", 72, 51, 78, 10)
GUICtrlSetFont(-1, 7, -1, -1, "Curier New")
Global $hLabelDuration = GUICtrlCreateLabel("", 428, 51, 72, 10)
GUICtrlSetFont(-1, 7, -1, -1, "Curier New")

Global $hButtonL = GUICtrlCreateButton("<<", 48, 52, 21, 21)
GUICtrlSetFont(-1, 9, 600, -1, "MS Sans Serif")
Global $hButtonR = GUICtrlCreateButton(">>", 501, 52, 21, 21)
GUICtrlSetFont(-1, 9, 600, -1, "MS Sans Serif")

Global $hButtonStop = GUICtrlCreateButton("&Stop", 140, 20, 70, 25)
Global $hButtonPlay = GUICtrlCreateButton("&Pause", 220, 20, 115, 25)
Global $hButtonBrowse = GUICtrlCreateButton("&Load", 430, 20, 90, 25)
Global $hButtonFit = GUICtrlCreateButton("Fit &window", 350, 20, 70, 25)

Global $hLevMet

; Objects
Global $oTaskbarList3, $oCustomDestinationList
Global $oGraphBuilder, $oMediaControl, $oMediaEventEx, $oVideoWindow, $oMediaPosition, $oBasicAudio, $oBasicVideo
Global $oEndpointVolume, $oAudioMeterInformation

; Level-meter
_AudioVolObject($oEndpointVolume, $oAudioMeterInformation)
If Not @error Then ; if this objects are available on the system then add control for it
	$hLevMet = GUICtrlCreateProgress(530, 15, 40, 60, 4)
	AdlibRegister("_LevelMeter", 45)
EndIf

; Misc variables
Global $iPlaying = 1, $iVol, $iUnFit = 1, $iPos
Global $vDuration, $vCurrent, $sElapsed, $sDuration
Global $hIWindow

; Additional message processing
GUIRegisterMsg($WM_MOVE, "_WM_MOVE")
GUIRegisterMsg($WM_SIZE, "_WM_SIZE")
GUIRegisterMsg($WM_GETMINMAXINFO, "_WM_GETMINMAXINFO")
GUIRegisterMsg(563, "_WM_DROPFILES") ; $WM_DROPFILES
GUIRegisterMsg($WM_SYSCOMMAND, "_WM_SYSCOMMAND")
GUIRegisterMsg($WM_COMMAND, '_WM_COMMAND')
GUIRegisterMsg($WM_TASKBUTT_CREATED, '_WM_TASKBUTT_CREATED')
; Custom one
Global Const $WM_COMMUNICATE = _RegisterMessage($sGUID_WinMessage)

If IsAdmin() Then ; Allow to receive this messages if run elevated
	_ChangeWindowMessageFilterEx($hGUI, $WM_TASKBUTT_CREATED, 1)
	_ChangeWindowMessageFilterEx($hGUI, $WM_COMMAND, 1)
	_ChangeWindowMessageFilterEx($hGUI, $WM_COMMUNICATE, 1)
EndIf

; Progress 'monitoring'
AdlibRegister("_SetProgress", 160)

; Show GUI
GUISetState()

; Tip
$oTaskbarList3.SetThumbnailTooltip(Number($hGUI), "AutoItObject Player")

; Main loop
While 1
	Switch GUIGetMsg()
		Case -3
			ExitLoop
		Case $GUI_EVENT_PRIMARYUP
			_InvalidateChild($hGUI)
			GUICtrlSetState($hButtonPlay, $GUI_FOCUS)
		Case $hButtonFit
			If $iUnFit Then
				$iUnFit = 0
				GUICtrlSetData($hButtonFit, "O&riginal size")
			Else
				$iUnFit = 1
				GUICtrlSetData($hButtonFit, "Fit &window")
			EndIf
			_SetSize($oVideoWindow, $oBasicVideo, $hGUI)
		Case $hButtonStop
			$oMediaPosition.put_CurrentPosition(0)
			$oMediaControl.Stop()
			GUICtrlSetData($hButtonPlay, "&Play")
			GUICtrlSetData($hLabelPos, "0.0 sec")
			$iPlaying = 0
			$oTaskbarList3.SetProgressValue(Number($hGUI), 0, 100)
		Case $hButtonPlay
			If $iPlaying Then
				$oMediaControl.Pause()
				GUICtrlSetData($hButtonPlay, "&Play")
				$iPlaying = 0
			Else
				$oMediaControl.Run()
				GUICtrlSetData($hButtonPlay, "&Pause")
				$iPlaying = 1
			EndIf
		Case $hButtonBrowse
			$oTaskbarList3.SetProgressState(Number($hGUI), 1) ; TBPF_INDETERMINATE
			$sMediaFile = FileOpenDialog("Choose fle", "", "(*.flv;*.gif;*.bmp;*.jpg;*.wmv;*.avi;*.mpg;*.mp4;*.wmv;*.wma;*.mid;*.wav;*.mp3;*.rmi;*.aif;*.au;*.snd;*.kar)|All files(*)", 1)
			If @error Then $oTaskbarList3.SetProgressState(Number($hGUI), 0) ; TBPF_NOPROGRESS
		Case $hButtonL
			If IsObj($oMediaPosition) Then $oMediaPosition.put_CurrentPosition($vCurrent - $vDuration / 100)
		Case $hButtonR
			If IsObj($oMediaPosition) Then $oMediaPosition.put_CurrentPosition($vCurrent + $vDuration / 100)
	EndSwitch
	If $iVol <> GUICtrlRead($hVolSlider) Then
		$iVol = GUICtrlRead($hVolSlider)
		If IsObj($oBasicAudio) Then $oBasicAudio.put_Volume(-Exp(($iVol) / 10.86))
		GUICtrlSetTip($hVolSlider, 100 - $iVol & " %VOL")
	EndIf
	If $sMediaFile Then _RenderFile($sMediaFile)
WEnd

; Free before the end
_Quit()

;THE END





Func _Quit()
	; Two adlibs were "registered"
	AdlibUnRegister()
	AdlibUnRegister()
	; Release objests
	_ReleaseBuilder($oGraphBuilder, $oMediaControl, $oMediaEventEx, $oVideoWindow, $oMediaPosition, $oBasicAudio, $oBasicVideo)
	$oEndpointVolume = 0
	$oAudioMeterInformation = 0
	; Bye bye
	Exit
EndFunc   ;==>_Quit

Func _LevelMeter()
	Local $aCall ;= $oEndpointVolume.GetMasterVolumeLevelScalar(0)
	Local $iCurrentRead = 0;100 * $aCall[1] + 1
	$aCall = $oAudioMeterInformation.GetPeakValue(0)
	If IsArray($aCall) Then
		$iCurrentRead += 100 * $aCall[1]
		GUICtrlSetData($hLevMet, $iCurrentRead + 1)
		GUICtrlSetData($hLevMet, $iCurrentRead)
	EndIf
EndFunc   ;==>_LevelMeter

Func _CreateJumpList(ByRef $oCustomDestinationList)
	; Needed identifiers
	Local $sCLSID_DestinationList = "{77F10CF0-3DB5-4966-B520-B7C54FD35ED6}"
	Local $sIID_ICustomDestinationList = "{6332DEBF-87B5-4670-90C0-5E57B408A49E}"
	; Define ICustomDestinationList methods
	Local $tagICustomDestinationList = $dtagIUnknown & _
			"SetAppID hresult(wstr);" & _
			"BeginList hresult(dword*;ptr;ptr*);" & _
			"AppendCategory hresult(wstr;ptr);" & _
			"AppendKnownCategory hresult(dword);" & _
			"AddUserTasks hresult(ptr);" & _
			"CommitList hresult();" & _
			"GetRemovedDestinations hresult(ptr;ptr*);" & _
			"DeleteList hresult(wstr);" & _
			"AbortList hresult();" ; ICustomDestinationList
	; Wrapp ICustomDestinationList interface
	$oCustomDestinationList = _AutoItObject_ObjCreate($sCLSID_DestinationList, $sIID_ICustomDestinationList, $tagICustomDestinationList)

	; Setting MY App ID
	$oCustomDestinationList.SetAppID($APPID)

	; Call to BeginList is needed before Appending categorie(s)
	Local $IID_IObjectArray = _AutoItObject_CLSIDFromString("{92CA9DCD-5622-4BBA-A805-5E9F541BD8C9}")
	$oCustomDestinationList.BeginList(0, Number(DllStructGetPtr($IID_IObjectArray)), 0)

	; Add something to this category (optional really, since it's done automatically by the system later on)
	; For example on my system I have this:
	; _SHAddFileToRecentDocs(@HomeDrive & "\Users\Public\Pictures\Sample Pictures\Chrysanthemum.jpg")

	; Add 'Recent' category
	$oCustomDestinationList.AppendKnownCategory(2) ; KDC_RECENT
	; Add 'Frequent' category
	$oCustomDestinationList.AppendKnownCategory(1) ; KDC_FREQUENT

	; Add 'Tasks'. This is done in just a bit complicated way. Few steps needed...
	; Needed identifiers for IObjectCollection.
	Local $sCLSID_EnumerableObjectCollection = "{2D3468C1-36A7-43B6-AC24-D3F02FD9607A}"
	Local $sIID_IObjectCollection = "{5632B1A4-E38A-400A-928A-D4CD63230295}"
	; Define IObjectCollection interface methods
	Local $tagIObjectCollection = $dtagIUnknown & _
			"GetCount hresult(dword*);" & _
			"GetAt hresult(dword;ptr;ptr*);" & _ ; IObjectArray
			"AddObject hresult(ptr);" & _
			"AddFromArray hresult(ptr);" & _
			"RemoveObjectAt hresult(dword);" & _
			"Clear hresult();" ; IObjectCollection
	; Wrapp IObjectCollection interface
	Local $oObjectCollection = _AutoItObject_ObjCreate($sCLSID_EnumerableObjectCollection, $sIID_IObjectCollection, $tagIObjectCollection)
	; See if ok
	If Not IsObj($oObjectCollection) Then
		$oCustomDestinationList.CommitList()
		Return SetError(1, 1, True) ; setting @extended to 1
	EndIf
	; Needed identifiers for IShellLink
	Local $sCLSID_ShellLink = "{00021401-0000-0000-C000-000000000046}"
	Local $sIID_IShellLinkW = "{000214F9-0000-0000-C000-000000000046}"
	; Define IShellLink interface methods
	Local $tagIShellLink = $dtagIUnknown & _
			"GetPath hresult(wstr;int;ptr*;dword);" & _
			"GetIDList hresult(ptr*);" & _
			"SetIDList hresult(ptr);" & _
			"GetDescription hresult(wstr;int);" & _
			"SetDescription hresult(wstr);" & _
			"GetWorkingDirectory hresult(wstr;int);" & _
			"SetWorkingDirectory hresult(wstr);" & _
			"GetArguments hresult(wstr;int);" & _
			"SetArguments hresult(wstr);" & _
			"GetHotkey hresult(word*);" & _
			"SetHotkey hresult(word);" & _
			"GetShowCmd hresult(int*);" & _
			"SetShowCmd hresult(int);" & _
			"GetIconLocation hresult(wstr;int;ptr*);" & _
			"SetIconLocation hresult(wstr;int);" & _
			"SetRelativePath hresult(wstr);" & _
			"Resolve hresult(hwnd;dword);" & _
			"SetPath hresult(wstr);" ; IShellLinkW
	; Wrapp IShellLink interface
	Local $oShellLink = _AutoItObject_ObjCreate($sCLSID_ShellLink, $sIID_IShellLinkW, $tagIShellLink)
	; See if ok
	If Not IsObj($oShellLink) Then
		$oCustomDestinationList.CommitList()
		Return SetError(1, 2, True) ; setting @extended to 2
	EndIf
	; Customize it
	$oShellLink.SetPath(@AutoItExe)
	$oShellLink.SetArguments('"' & @ScriptName & '"' & " browse")
	$oShellLink.SetIconLocation("shell32.dll", -16769) ; For example that arrow for shortcuts
	$oShellLink.SetWorkingDirectory(@ScriptDir)
	$oShellLink.SetDescription("Browse... and play")

	; Ask for IPropertyStore pointer from oShellLink
	Local $tIID_IPropertyStore = _AutoItObject_CLSIDFromString("{886d8EEB-8CF2-4446-8D02-CDBA1DBDCF99}")
	Local $aCall = $oShellLink.QueryInterface(Number(DllStructGetPtr($tIID_IPropertyStore)), 0)
	If Not IsArray($aCall) Or Not $aCall[2] Then
		$oCustomDestinationList.CommitList()
		Return SetError(1, 3, True) ; setting @extended to 3
	EndIf
	Local $pPropertyStore = $aCall[2]
	; Define IPropertyStore interface methods
	Local $tagIPropertyStore = $dtagIUnknown & _
			"GetCount hresult(dword*);" & _
			"GetAt hresult(dword;ptr*);" & _
			"GetValue hresult(ptr;variant*);" & _
			"SetValue hresult(ptr;variant*);" & _
			"Commit hresult();" ; IPropertyStore
	; Wrapp IPropertyStore interface
	Local $oPropertyStore = _AutoItObject_WrapperCreate($pPropertyStore, $tagIPropertyStore)
	; See if ok
	If Not IsObj($oPropertyStore) Then
		$oCustomDestinationList.CommitList()
		Return SetError(1, 4, True) ; setting @extended to 4
	EndIf
	; Little complication now. SetValue method requires rather complicated params ( http://msdn.microsoft.com/en-us/library/bb761475(VS.85).aspx ). Ahh well...
	; Title is what I want to change. PKEY_Title is "{F29F85E0-4FF9-1068-AB91-08002B27B3D9}"
	Local $tGUIDByte = _AutoItObject_DllStructCreate("byte Data[16]", _AutoItObject_CLSIDFromString("{F29F85E0-4FF9-1068-AB91-08002B27B3D9}")) ; Copying to bytes structure for easy tranfer to new structure below
	Local $tREFPROPERTYKEY = _AutoItObject_DllStructCreate("byte GUID[16]; dword PID;")
	$tREFPROPERTYKEY.GUID = $tGUIDByte.Data
	$tREFPROPERTYKEY.PID = 2 ; PID_FIRST_USABLE
	; Set the title
	$oPropertyStore.SetValue($tREFPROPERTYKEY(), "Find something to play") ; so this is going to be displayed text for the task
	; Commit it now when decently costumized
	$oPropertyStore.Commit()

	; Add it to collection
	$oObjectCollection.AddObject($oShellLink.__ptr__) ; pointer is required. All wrapped objects expose this public readonly property. Isn't that something.

	; Ask for IObjectArray pointer from oShellLink because AddUserTasks requires pointer to it
	; (I could also just pass pointer to $oObjectCollection <<$oObjectCollection.__ptr__>> )
	Local $tIID_IObjectArray = _AutoItObject_CLSIDFromString("{92CA9DCD-5622-4BBA-A805-5E9F541BD8C9}")
	$aCall = $oObjectCollection.QueryInterface(Number(DllStructGetPtr($tIID_IObjectArray)), 0)
	If Not IsArray($aCall) Or Not $aCall[2] Then
		$oCustomDestinationList.CommitList()
		Return SetError(1, 5, True) ; setting @extended to 5
	EndIf
	Local $pObjectArray = $aCall[2]
	; And finally... the victory! (I hope)
	$oCustomDestinationList.AddUserTasks($pObjectArray)

	; All done. Commit the Jump List.
	$oCustomDestinationList.CommitList()

	; Return something maybe
	Return True
EndFunc   ;==>_CreateJumpList


Func _CreateTaskBarList(ByRef $oTaskbarList3)
	; Needed identifiers
	Local $sCLSID_TaskBarlist = "{56FDF344-FD6D-11D0-958A-006097C9A090}"
	Local $sIID_ITaskbarList3 = "{EA1AFB91-9E28-4B86-90E9-9E9F8A5EEFAF}"
	; Define ITaskbarList3 methods
	Local $tagITaskbarList3 = $dtagIUnknown & _
			"HrInit hresult();" & _
			"AddTab long(hwnd);" & _
			"DeleteTab hresult(hwnd);" & _
			"ActivateTab hresult(hwnd);" & _
			"SetActiveAlt hresult(hwnd);" & _ ; ITaskbarList
			"MarkFullscreenWindow hresult(hwnd;int);" & _ ; ITaskbarList2
			"SetProgressValue hresult(hwnd;uint64;uint64);" & _
			"SetProgressState hresult(hwnd;int);" & _
			"RegisterTab hresult(hwnd;hwnd);" & _
			"UnregisterTab hresult(hwnd);" & _
			"SetTabOrder hresult(hwnd;hwnd);" & _
			"SetTabActive hresult(hwnd;hwnd;dword);" & _
			"ThumbBarAddButtons hresult(hwnd;uint;ptr);" & _
			"ThumbBarUpdateButtons hresult(hwnd;uint;ptr);" & _
			"ThumbBarSetImageList hresult(hwnd;ptr);" & _
			"SetOverlayIcon hresult(hwnd;ptr;wstr);" & _
			"SetThumbnailTooltip hresult(hwnd;wstr);" & _
			"SetThumbnailClip hresult(hwnd;ptr);" ; ITaskbarList3
	; Wrapp ITaskbarList3 interface
	$oTaskbarList3 = _AutoItObject_ObjCreate($sCLSID_TaskBarlist, $sIID_ITaskbarList3, $tagITaskbarList3)
	; Init
	$oTaskbarList3.HrInit()
	Return True
EndFunc   ;==>_CreateTaskBarList

Func _AddTaskbarButtons($hGUI);, ByRef $tTHUMBBUTTON)
	; Data type for the last element of $tagTHUMBBUTTON is (wrongly) 'dword_ptr' only because of AutoIt's inability to accept alignment of the part of the structure tag.
	; Issue arises when there's a need for an array of properly aligned structures. Usualy it's x64 issue, but can be encountered with x86 too.
	; Maybe some day devs will add new syntax elements to have that option. Anyway:
	Local $tagTHUMBBUTTON = "dword Mask; dword Id; dword Bitmap; handle Icon; wchar Tip[260]; dword_ptr Flags;"
	; Will have 5 buttons
	Local $iButtons = 5
	For $i = 1 To $iButtons
		$tagTHUMBBUTTON &= $tagTHUMBBUTTON
	Next
	Local $tTHUMBBUTTON = DllStructCreate($tagTHUMBBUTTON)
	; Fill the structure. I'm going with icons for buttons (imagelist would be simpler maybe).
	Local $sTip, $hIcon
	For $i = 0 To $iButtons - 1
		DllStructSetData($tTHUMBBUTTON, 1 + (6 * $i), 6) ; Mask = THB_ICON | THB_TOOLTIP
		DllStructSetData($tTHUMBBUTTON, 2 + (6 * $i), 1000 + $i) ; Id
		DllStructSetData($tTHUMBBUTTON, 3 + (6 * $i), -1)
		Switch $i
			Case 0
				$sTip = "Rewind"
				$hIcon = _CreateHIconFromBinaryImage(_BinaryImageRew())
			Case 1
				$sTip = "Stop"
				$hIcon = _CreateHIconFromBinaryImage(_BinaryImageStop())
			Case 2
				$sTip = "Play"
				$hIcon = _CreateHIconFromBinaryImage(_BinaryImagePlay())
			Case 3
				$sTip = "Pause"
				$hIcon = _CreateHIconFromBinaryImage(_BinaryImagePause())
			Case 4
				$sTip = "Forward"
				$hIcon = _CreateHIconFromBinaryImage(_BinaryImageFwd())
		EndSwitch
		DllStructSetData($tTHUMBBUTTON, 4 + (6 * $i), $hIcon) ; Icon handle (when app would be done icons will be destroyed by the system)
		DllStructSetData($tTHUMBBUTTON, 5 + (6 * $i), $sTip) ; Tip to show
		DllStructSetData($tTHUMBBUTTON, 6 + (6 * $i), 0) ; Flags = THBF_ENABLED
	Next
	; Add buttons
	$oTaskbarList3.ThumbBarAddButtons(Number($hGUI), $iButtons, Number(DllStructGetPtr($tTHUMBBUTTON)))
EndFunc   ;==>_AddTaskbarButtons

Func _AudioVolObject(ByRef $oEndpointVolume, ByRef $oAudioMeterInformation)
	Local Const $sCLSID_MMDeviceEnumerator = "{BCDE0395-E52F-467C-8E3D-C4579291692E}"
	Local Const $sIID_IMMDeviceEnumerator = "{A95664D2-9614-4F35-A746-DE8DB63617E6}"
	Global $dtagIMMDeviceEnumerator = $dtagIUnknown & _
			"EnumAudioEndpoints hresult(dword;dword;ptr*);" & _
			"GetDefaultAudioEndpoint hresult(dword;dword;ptr*);" & _
			"GetDevice hresult(wstr;ptr*);" & _
			"RegisterEndpointNotificationCallback hresult(ptr);" & _
			"UnregisterEndpointNotificationCallback hresult(ptr);"

	Local Const $sIID_IMMDevice = "{D666063F-1587-4E43-81F1-B948E807363F}"
	#forceref $sIID_IMMDevice
	Local $dtagIMMDevice = $dtagIUnknown & _
			"Activate hresult(ptr;dword;variant*;ptr*);" & _
			"OpenPropertyStore hresult(dword;ptr*);" & _
			"GetId hresult(wstr*);" & _
			"GetState hresult(dword*);"

	Local Const $sIID_IAudioEndpointVolume = "{5CDF2C82-841E-4546-9722-0CF74078229A}"
	Local $dtagIAudioEndpointVolume = $dtagIUnknown & _
			"RegisterControlChangeNotify hresult(ptr);" & _
			"UnregisterControlChangeNotify hresult(ptr);" & _
			"GetChannelCount hresult(dword*);" & _
			"SetMasterVolumeLevel hresult(float;ptr);" & _
			"SetMasterVolumeLevelScalar hresult(float;ptr);" & _
			"GetMasterVolumeLevel hresult(float*);" & _
			"GetMasterVolumeLevelScalar hresult(float*);" & _
			"SetChannelVolumeLevel hresult(dword;float;ptr);" & _
			"SetChannelVolumeLevelScalar hresult(dword;float;ptr);" & _
			"GetChannelVolumeLevel hresult(dword;float*);" & _
			"GetChannelVolumeLevelScalar hresult(dword;float*);" & _
			"SetMute hresult(bool);" & _
			"GetMute hresult(bool*);" & _
			"GetVolumeStepInfo hresult(dword*;dword*);" & _
			"VolumeStepUp hresult(ptr);" & _
			"VolumeStepDown hresult(ptr);" & _
			"QueryHardwareSupport hresult(dword*);" & _
			"GetVolumeRange hresult(float*;float*;float*);"

	Local Const $sIID_IAudioMeterInformation = "{C02216F6-8C67-4B5B-9D00-D008E73E0064}"
	Local $dtagIAudioMeterInformation = $dtagIUnknown & _
			"GetPeakValue hresult(float*);" & _
			"GetMeteringChannelCount hresult(dword*);" & _
			"GetChannelsPeakValues hresult(dword;float*);" & _
			"QueryHardwareSupport hresult(dword*);"

	; Sequences of code below are taken from the source of plugin written for AutoIt for setting master volume on Vista and above systems.
	; Code was written by wraithdu in C++.

	; MMDeviceEnumerator
	Local $oMMDeviceEnumerator = _AutoItObject_ObjCreate($sCLSID_MMDeviceEnumerator, $sIID_IMMDeviceEnumerator, $dtagIMMDeviceEnumerator)
	If @error Then Return SetError(1, 0, 0)

	; DefaultAudioEndpoint
	Local $aCall = $oMMDeviceEnumerator.GetDefaultAudioEndpoint(0, 0, 0) ; eRender, eConsole
	If Not IsArray($aCall) Then Return SetError(2, 0, 0)
	Local $oDefaultDevice = _AutoItObject_WrapperCreate($aCall[3], $dtagIMMDevice)

	; AudioEndpointVolume object
	Local $pIID_IAudioEndpointVolume = _AutoItObject_CLSIDFromString($sIID_IAudioEndpointVolume)
	$aCall = $oDefaultDevice.Activate(Number(DllStructGetPtr($pIID_IAudioEndpointVolume)), 1, 0, 0)
	If Not IsArray($aCall) Then Return SetError(3, 0, 0)
	$oEndpointVolume = _AutoItObject_WrapperCreate($aCall[4], $dtagIAudioEndpointVolume)

	; AudioMeterInformation
	Local $pIID_IAudioMeterInformation = _AutoItObject_CLSIDFromString($sIID_IAudioMeterInformation)
	$aCall = $oDefaultDevice.Activate(Number(DllStructGetPtr($pIID_IAudioMeterInformation)), 1, 0, 0)
	If Not IsArray($aCall) Then Return SetError(3, 0, 0)
	$oAudioMeterInformation = _AutoItObject_WrapperCreate($aCall[4], $dtagIAudioMeterInformation)

	; That's it
	Return True
EndFunc   ;==>_AudioVolObject

Func _InitBuilder(ByRef $oGraphBuilder, ByRef $oMediaControl, ByRef $oMediaEventEx, ByRef $oVideoWindow, ByRef $oMediaPosition, ByRef $oBasicAudio, ByRef $oBasicVideo)
	; Needed identifiera
	Local $sCLSID_FilterGraph = "{E436EBB3-524F-11CE-9F53-0020AF0BA770}"
	Local $sIID_IGraphBuilder = "{56A868A9-0AD4-11CE-B03A-0020AF0BA770}"
	; More...
	Local $tIID_IMediaPosition = _AutoItObject_CLSIDFromString("{56A868B2-0AD4-11CE-B03A-0020AF0BA770}")
	Local $tIID_IMediaControl = _AutoItObject_CLSIDFromString("{56A868B1-0AD4-11CE-B03A-0020AF0BA770}")
	Local $tIID_IMediaEventEx = _AutoItObject_CLSIDFromString("{56A868C0-0AD4-11CE-B03A-0020AF0BA770}")
	Local $tIID_IVideoWindow = _AutoItObject_CLSIDFromString("{56A868B4-0AD4-11CE-B03A-0020AF0BA770}")
	Local $tIID_IBasicAudio = _AutoItObject_CLSIDFromString("{56A868B3-0AD4-11CE-B03A-0020AF0BA770}")
	Local $tIID_IBasicVideo = _AutoItObject_CLSIDFromString("{56A868B5-0AD4-11CE-B03A-0020AF0BA770}")

	; Define IGraphBuilder methods
	Local $dtagIGraphBuilder = $dtagIUnknown & _
			"AddFilter hresult(ptr;wstr);" & _
			"RemoveFilter hresult(ptr);" & _
			"EnumFilters hresult(ptr*);" & _
			"FindFilterByName hresult(wstr;ptr*);" & _
			"ConnectDirect hresult(ptr;ptr;ptr);" & _
			"Reconnect hresult(ptr);" & _
			"Disconnect hresult(ptr);" & _
			"SetDefaultSyncSource hresult();" & _ ; IFilterGraph
			"Connect hresult(ptr;ptr);" & _
			"Render hresult(ptr);" & _
			"RenderFile hresult(wstr;ptr);" & _
			"AddSourceFilter hresult(wstr;wstr;ptr*);" & _
			"SetLogFile hresult(dword_ptr);" & _
			"Abort hresult();" & _
			"ShouldOperationContinue hresult();" ; IGraphBuilder

	; Wrapp IGraphBuilder interface
	$oGraphBuilder = _AutoItObject_ObjCreate($sCLSID_FilterGraph, $sIID_IGraphBuilder, $dtagIGraphBuilder)
	If @error Then Return SetError(1, 0, False)

	; IMediaControl IDispatch
	Local $aCall = $oGraphBuilder.QueryInterface(Number(DllStructGetPtr($tIID_IMediaControl)), 0)
	If IsArray($aCall) And $aCall[2] Then
		$oMediaControl = _AutoItObject_PtrToIDispatch($aCall[2])
	Else
		Return SetError(2, 0, False)
	EndIf

	; IMediaEventEx IDispatch
	$aCall = $oGraphBuilder.QueryInterface(Number(DllStructGetPtr($tIID_IMediaEventEx)), 0)
	If IsArray($aCall) And $aCall[2] Then
		$oMediaEventEx = _AutoItObject_PtrToIDispatch($aCall[2])
	Else
		Return SetError(3, 0, False)
	EndIf

	Local $pVideoWindow
	; Get pointer to IVideoWindow interface
	$aCall = $oGraphBuilder.QueryInterface(Number(DllStructGetPtr($tIID_IVideoWindow)), 0)
	If IsArray($aCall) And $aCall[2] Then
		$pVideoWindow = $aCall[2]
	Else
		Return SetError(4, 0, False)
	EndIf

	; IVideoWindow is dual interface. Defining vTable methods:
	Local $dtagIVideoWindow = $dtagIDispatch & _
			"put_Caption hresult(bstr);" & _
			"get_Caption hresult(bstr*);" & _
			"put_WindowStyle hresult(long);" & _
			"get_WindowStyle hresult(long*);" & _
			"put_WindowStyleEx hresult(long);" & _
			"put_WindowStyleEx hresult(long*);" & _
			"put_AutoShow hresult(long);" & _
			"get_AutoShow hresult(long*);" & _
			"put_WindowState hresult(long);" & _
			"get_WindowState hresult(long*);" & _
			"put_BackgroundPalette hresult(long);" & _
			"get_BackgroundPalette hresult(long*);" & _
			"put_Visible hresult(long);" & _
			"get_Visible hresult(long*);" & _
			"put_Left hresult(long);" & _
			"get_Left hresult(long*);" & _
			"put_Width hresult(long);" & _
			"get_Width hresult(long*);" & _
			"put_Top hresult(long);" & _
			"get_Top hresult(long*);" & _
			"put_Height hresult(long);" & _
			"get_Height hresult(long*);" & _
			"put_Owner hresult(long_ptr);" & _
			"get_Owner hresult(long_ptr*);" & _
			"put_MessageDrain hresult(long_ptr);" & _
			"get_MessageDrain hresult(long_ptr*);" & _
			"get_BorderColor hresult(long*);" & _
			"put_BorderColor hresult(long);" & _
			"get_FullScreenMode hresult(long*);" & _
			"put_FullScreenMode hresult(long);" & _
			"SetWindowForeground hresult(long);" & _
			"NotifyOwnerMessage hresult(long_ptr;long;long_ptr;long_ptr);" & _
			"SetWindowPosition hresult(long;long;long;long);" & _
			"GetWindowPosition hresult(long*;long*;long*;long*);" & _
			"GetMinIdealImageSize hresult(long*;long*);" & _
			"GetMaxIdealImageSize hresult(long*;long*);" & _
			"GetRestorePosition hresult(long*;long*;long*;long*);" & _
			"HideCursor hresult(long);" & _
			"IsCursorHidden hresult(long*);" ; IVideoWindow

	; Wrapp it:
	$oVideoWindow = _AutoItObject_WrapperCreate($pVideoWindow, $dtagIVideoWindow)
	If @error Then Return SetError(5, 0, False)

	Local $pMediaPosition
	; Get pointer to IMediaPosition interface
	$aCall = $oGraphBuilder.QueryInterface(Number(DllStructGetPtr($tIID_IMediaPosition)), 0)
	If IsArray($aCall) And $aCall[2] Then
		$pMediaPosition = $aCall[2]
	Else
		Return SetError(6, 0, False)
	EndIf

	; IMediaPosition is dual interface. Defining vTable methods:
	Local $dtagIMediaPosition = $dtagIDispatch & _
			"get_Duration hresult(double*);" & _
			"put_CurrentPosition hresult(double);" & _
			"get_CurrentPosition hresult(double*);" & _
			"get_StopTime hresult(double*);" & _
			"put_StopTime hresult(double);" & _
			"get_PrerollTime hresult(double*);" & _
			"put_PrerollTime hresult(double);" & _
			"put_Rate hresult(double);" & _
			"get_Rate hresult(double*);" & _
			"CanSeekForward hresult(long*);" & _
			"CanSeekBackward hresult(long*);" ; IMediaPosition

	; Wrapp it:
	$oMediaPosition = _AutoItObject_WrapperCreate($pMediaPosition, $dtagIMediaPosition)
	If @error Then Return SetError(7, 0, False)

	Local $pBasicAudio
	; Get pointer to IBasicAudio interface
	$aCall = $oGraphBuilder.QueryInterface(Number(DllStructGetPtr($tIID_IBasicAudio)), 0)
	If IsArray($aCall) And $aCall[2] Then
		$pBasicAudio = $aCall[2]
	Else
		Return SetError(8, 0, False)
	EndIf

	; IBasicAudio is dual interface. Defining vTable methods:
	Local $dtagIBasicAudio = $dtagIDispatch & _
			"put_Volume hresult(long);" & _
			"get_Volume hresult(long*);" & _
			"put_Balance hresult(long);" & _
			"get_Balance hresult(long*);" ; IBasicAudio

	; Wrapp it:
	$oBasicAudio = _AutoItObject_WrapperCreate($pBasicAudio, $dtagIBasicAudio)
	If @error Then Return SetError(9, 0, False)

	Local $pIBasicVideo
	; Get pointer to IBasicVideo interface
	$aCall = $oGraphBuilder.QueryInterface(Number(DllStructGetPtr($tIID_IBasicVideo)), 0)
	If IsArray($aCall) And $aCall[2] Then
		$pIBasicVideo = $aCall[2]
	Else
		Return SetError(10, 0, False)
	EndIf

	; IBasicVideo is dual interface. Defining vTable methods:
	Local $dtagIBasicVideo = $dtagIDispatch & _
			"get_AvgTimePerFrame hresult(double*);" & _
			"get_BitRate hresult(long*);" & _
			"get_BitErrorRate hresult(long*);" & _
			"get_VideoWidth hresult(long*);" & _
			"get_VideoHeight hresult(long*);" & _
			"put_SourceLeft hresult(long);" & _
			"get_SourceLeft hresult(long*);" & _
			"put_SourceWidth hresult(long);" & _
			"get_SourceWidth hresult(long*);" & _
			"put_SourceTop hresult(long);" & _
			"get_SourceTop hresult(long*);" & _
			"put_SourceHeight hresult(long);" & _
			"get_SourceHeight hresult(long*);" & _
			"put_DestinationLeft hresult(long);" & _
			"get_DestinationLeft hresult(long*);" & _
			"put_DestinationWidth hresult(long);" & _
			"get_DestinationWidth hresult(long*);" & _
			"put_DestinationTop hresult(long);" & _
			"get_DestinationTop hresult(long*);" & _
			"put_DestinationHeight hresult(long);" & _
			"get_DestinationHeight hresult(long*);" & _
			"SetSourcePosition hresult(long;long;long;long);" & _
			"GetSourcePosition hresult(long*;long*;long*;long*);" & _
			"SetDefaultSourcePosition hresult();" & _
			"SetDestinationPosition hresult(long;long;long;long);" & _
			"GetDestinationPosition hresult(long*;long*;long*;long*);" & _
			"SetDefaultDestinationPosition hresult();" & _
			"GetVideoSize hresult(long*;long*);" & _
			"GetVideoPaletteEntries hresult(long;long;long*;long*);" & _
			"GetCurrentImage hresult(long*;long*);" & _
			"IsUsingDefaultSource hresult();" & _
			"IsUsingDefaultDestination hresult();" ; IBasicVideo

	; Wrapp it:
	$oBasicVideo = _AutoItObject_WrapperCreate($pIBasicVideo, $dtagIBasicVideo)
	If @error Then Return SetError(11, 0, False)

	Return True ; There
EndFunc   ;==>_InitBuilder

Func _ReleaseBuilder(ByRef $oGraphBuilder, ByRef $oMediaControl, ByRef $oMediaEventEx, ByRef $oVideoWindow, ByRef $oMediaPosition, ByRef $oBasicAudio, ByRef $oBasicVideo)
	$oMediaControl.Stop()
	$oVideoWindow.put_Visible(0)
	$oVideoWindow.put_Owner(0)
	$oVideoWindow.Release() ;<-!
	$oMediaPosition = 0
	$oBasicAudio = 0
	$oBasicVideo = 0
	$oVideoWindow = 0
	$oMediaControl = 0
	$oMediaEventEx = 0
	$oGraphBuilder.Release() ;<-!
	$oGraphBuilder = 0
EndFunc   ;==>_ReleaseBuilder


Func _RenderFile(ByRef $sMediaFile)
	$oTaskbarList3.SetProgressValue(Number($hGUI), 100, 100)
	$oTaskbarList3.SetProgressState(Number($hGUI), 8); TBPF_PAUSED
	_ReleaseBuilder($oGraphBuilder, $oMediaControl, $oMediaEventEx, $oVideoWindow, $oMediaPosition, $oBasicAudio, $oBasicVideo)
	_InitBuilder($oGraphBuilder, $oMediaControl, $oMediaEventEx, $oVideoWindow, $oMediaPosition, $oBasicAudio, $oBasicVideo)
	Local $aCall = $oGraphBuilder.RenderFile($sMediaFile, 0)
    ; Check for failure
	If IsArray($aCall) Then
		If $aCall[0] Then
			; Try alternative loading and if that fails return error
			If Not _WMAsfReaderLoad($sMediaFile) Then
				_MessageBeep(48)
				$sMediaFile = ""
				$oTaskbarList3.SetProgressState(Number($hGUI), 0) ; TBPF_NOPROGRESS
				Return SetError(1, 0, False)
			EndIf
		EndIf
	Else
		_MessageBeep(48)
		$sMediaFile = ""
		$oTaskbarList3.SetProgressState(Number($hGUI), 0) ; TBPF_NOPROGRESS
		Return SetError(2, 0, False)
	EndIf
	_SHAddFileToRecentDocs($sMediaFile)
	_SetInitialSizeAndCaption($oVideoWindow, $oBasicVideo, $hGUI)
	$oVideoWindow.put_Owner(Number($hGUI))
	$oVideoWindow.put_WindowStyle(BitOR($WS_CHILD, $WS_CLIPCHILDREN))
	$oBasicAudio.put_Volume(-Exp((GUICtrlRead($hVolSlider)) / 10.86))
	$oMediaControl.Run()
	$vDuration = $oMediaPosition.get_Duration(0)
	$vDuration = $vDuration[1]
	If $vDuration Then
		If $vDuration < 60 Then
			$sDuration = StringFormat("    %.1f sec", $vDuration)
		Else
			$sDuration = StringFormat('%d min %.1f sec', Floor($vDuration / 60), Mod($vDuration, 60))
		EndIf
		GUICtrlSetState($hButtonStop, $GUI_ENABLE)
		GUICtrlSetState($hButtonPlay, $GUI_ENABLE)
		GUICtrlSetState($hButtonL, $GUI_ENABLE)
		GUICtrlSetState($hButtonR, $GUI_ENABLE)
		GUICtrlSetState($hPosProgress, $GUI_ENABLE)
		GUICtrlSetState($hVolSlider, $GUI_ENABLE)
	Else
		$sDuration = ""
		GUICtrlSetState($hButtonStop, $GUI_DISABLE)
		GUICtrlSetState($hButtonPlay, $GUI_DISABLE)
		GUICtrlSetState($hButtonL, $GUI_DISABLE)
		GUICtrlSetState($hButtonR, $GUI_DISABLE)
		GUICtrlSetState($hPosProgress, $GUI_DISABLE)
		GUICtrlSetState($hVolSlider, $GUI_DISABLE)
	EndIf
	GUICtrlSetData($hLabelDuration, $sDuration)
	GUICtrlSetData($hPosProgress, 0)
	GUICtrlSetData($hButtonPlay, "&Pause")
	GUICtrlSetData($hLabelPos, "")
	$iUnFit = 1
	GUICtrlSetData($hButtonFit, "Fit &window")
	$oVideoWindow.put_Visible(-1)
	$sMediaFile = ""
	_SetSize($oVideoWindow, $oBasicVideo, $hGUI)
	$iPlaying = 1
	GUICtrlSetState($hButtonPlay, $GUI_FOCUS)
	$oTaskbarList3.SetProgressState(Number($hGUI), 0) ; TBPF_NOPROGRESS
	Return True
EndFunc   ;==>_RenderFile

Func _WMAsfReaderLoad($sFile)
	Local Const $sCLSID_WMAsfReader = "{187463A0-5BB7-11d3-ACBE-0080C75E246E}"
	; IBaseFilter definition
	Local Const $sIID_IBaseFilter = "{56a86895-0ad4-11ce-b03a-0020af0ba770}"
	Local $dtagIBaseFilter = $dtagIUnknown & _
			"GetClassID hresult(ptr*);" & _; IPersist
			"Stop hresult();" & _
			"Pause hresult();" & _
			"Run hresult(int64);" & _
			"GetState hresult(dword;dword*);" & _
			"SetSyncSource hresult(ptr);" & _
			"GetSyncSource hresult(ptr*);" & _ ; IMediaFilter
			"EnumPins hresult(ptr*);" & _
			"FindPin hresult(wstr;ptr*);" & _
			"QueryFilterInfo hresult(ptr*);" & _
			"JoinFilterGraph hresult(ptr;wstr);" & _
			"QueryVendorInfo hresult(wstr*);" ; IBaseFilter
    ; Create object
	Local $oBaseFilter = _AutoItObject_ObjCreate($sCLSID_WMAsfReader, $sIID_IBaseFilter, $dtagIBaseFilter)
	If @error Then Return SetError(1, 0, False)
    ; AddFilter is "must" to be able to use it
	$oGraphBuilder.AddFilter($oBaseFilter.__ptr__, "trancexx") ; Well you know... fame and glory

    ; File will be loaded using FileSourceFilter object
	; IFileSourceFilter definition
	Local Const $sIID_IFileSourceFilter = "{56a868a6-0ad4-11ce-b03a-0020af0ba770}"
	Local $dtagIFileSourceFilter = $dtagIUnknown & _
			"Load hresult(wstr;ptr);" & _
			"GetCurFile hresult(wstr*;ptr*);"

	Local $tIID_IFileSourceFilter = _AutoItObject_CLSIDFromString($sIID_IFileSourceFilter)
	; Ask for FileSourceFilter object from BaseFilter
	Local $aCall = $oBaseFilter.QueryInterface(Number(DllStructGetPtr($tIID_IFileSourceFilter)), 0)
	If Not IsArray($aCall) Then Return SetError(2, 0, False)
	; Wrapp it
	Local $oFileSourceFilter = _AutoItObject_WrapperCreate($aCall[2], $dtagIFileSourceFilter)

	; Load the file now
	$oFileSourceFilter.Load($sFile, 0)

	; Get pointer to EnumPins object
	$aCall = $oBaseFilter.EnumPins(0)
	If Not IsArray($aCall) Or Not $aCall[1] Then Return SetError(3, 0, False)
	Local $pEnum = $aCall[1]

	; Define IEnumPins methods
	Local $dtagIEnumPins = $dtagIUnknown & _
			"Next hresult(dword;ptr*;dword*);" & _
			"Skip hresult(dword);" & _
			"Reset hresult();" & _
			"Clone hresult(ptr*);"
	; Wrapp it
	Local $oEnum = _AutoItObject_WrapperCreate($pEnum, $dtagIEnumPins)

	; Will enumerate all PINs and render them
	Local $pPin
	While 1
		$aCall = $oEnum.Next(1, 0, 0)
		If Not IsArray($aCall) Then Return SetError(4, 0, False)
		$pPin = $aCall[2]
		If $pPin Then
			$oGraphBuilder.Render($pPin)
			_AutoItObject_IUnknownRelease($pPin); releasing non-wrapped object when no longer needed
		EndIf
		If $aCall[0] Then ExitLoop
	WEnd

	; Alright!
	Return True
EndFunc   ;==>_WMAsfReaderLoad

Func _SetInitialSizeAndCaption($oVideoWindow, $oBasicVideo, $hGUI)
	Local $sFile = StringRegExpReplace(FileGetLongName($sMediaFile), ".*\\|\.xm", "")
	$oTaskbarList3.SetThumbnailTooltip(Number($hGUI), "AutoItObject playing:" & @LF & "- " & $sFile)
	Local $aCall = $oVideoWindow.put_Caption($sFile)
	$aCall = $oVideoWindow.get_Caption("")
	WinActivate($hGUI)
	Local $aPos = WinGetPos($hGUI)
	Local $iNewPosY
	If $aCall[0] Then ; audio window
		$hIWindow = 0
		$iNewPosY = $aPos[1] - (100 - $aPos[3]) / 2
		If $iNewPosY < 0 Then $iNewPosY = 0
		If $iNewPosY > @DesktopHeight - 160 Then $iNewPosY = @DesktopHeight - 160 ; not to lose it
		GUICtrlSetState($hButtonFit, $GUI_DISABLE)
		WinMove($hGUI, 0, $aPos[0], $iNewPosY, 530, 100)
		GUISetStyle(BitOR($WS_MINIMIZEBOX, $WS_CAPTION, $WS_POPUP, $WS_SYSMENU), $WS_EX_ACCEPTFILES)
	Else ; video window
		$hIWindow = WinGetHandle($aCall[1])
		GUICtrlSetState($hButtonFit, $GUI_ENABLE)
		$aCall = $oBasicVideo.GetVideoSize(0, 0)
		If $iUnFit Then
			If $aPos[2] > $aCall[1] + 130 Then
				$iNewPosY = $aPos[1] - ($aCall[2] + 130 - $aPos[3])
				If $iNewPosY > @DesktopHeight - $aCall[2] - 190 Then $iNewPosY = @DesktopHeight - $aCall[2] - 190 ; not to lose it (probably can be done better)
				If $iNewPosY < 0 Then $iNewPosY = 0
				WinMove($hGUI, 0, $aPos[0], $iNewPosY, 530, $aCall[2] + 130)
			Else
				$iNewPosY = $aPos[1] - (600 - $aPos[3]) / 2
				If $iNewPosY > @DesktopHeight - $aCall[2] - 190 Then $iNewPosY = @DesktopHeight - $aCall[2] - 190 ; not to lose it (same remark as above)
				If $iNewPosY < 0 Then $iNewPosY = 0
				WinMove($hGUI, 0, $aPos[0], $iNewPosY, 530, 600)
			EndIf
		Else

		EndIf
		GUISetStyle(BitOR($WS_OVERLAPPEDWINDOW, $WS_CLIPCHILDREN), $WS_EX_ACCEPTFILES)
	EndIf
EndFunc   ;==>_SetInitialSizeAndCaption

Func _SetSize($oVideoWindow, $oBasicVideo, $hGUI)
	If Not IsObj($oVideoWindow) Or Not IsObj($oBasicVideo) Then Return
	Local $aClientSize = WinGetClientSize($hGUI)
	Local $aCall = $oBasicVideo.GetVideoSize(0, 0)
	Local $iX, $iY
	Local $iWidth = $aClientSize[0], $iHeight = $aClientSize[1] - 80
	If IsArray($aCall) And $iUnFit Then
		;If $iWidth > $aCall[1] Or $iHeight > $aCall[2] Then
		$iX = ($iWidth - $aCall[1]) / 2
		$iY = ($iHeight - $aCall[2]) / 2
		$iWidth = $aCall[1]
		$iHeight = $aCall[2]
		If $iY + $iHeight + 80 > $aClientSize[1] Then $iY = $aClientSize[1] - 80 - $aCall[2]
		;EndIf
	EndIf
	$oVideoWindow.SetWindowPosition($iX, $iY, $iWidth, $iHeight)
	Return 1
EndFunc   ;==>_SetSize

Func _SetProgress()
	If IsObj($oMediaPosition) Then
		$vCurrent = $oMediaPosition.get_CurrentPosition(0)
		$vCurrent = $vCurrent[1]
		$iPos = 100 * $vCurrent / $vDuration
		If $vDuration Then
			If $vCurrent = $vDuration Then
				GUICtrlSetData($hButtonPlay, "&Play")
				$oMediaPosition.put_CurrentPosition(0)
				$oMediaControl.Stop()
				GUICtrlSetData($hLabelPos, "0.0 sec")
				$iPlaying = 0
			EndIf
			If $vCurrent > $vDuration Then $oMediaPosition.put_CurrentPosition(0)
			GUICtrlSetData($hPosProgress, $iPos)
			$oTaskbarList3.SetProgressValue(Number($hGUI), $iPos, 100)
			Local $sCurrent
			If $vCurrent < 60 Then
				$sCurrent = StringFormat("%.1f sec", $vCurrent)
			Else
				$sCurrent = StringFormat('%d min %.1f sec', Floor($vCurrent / 60), Mod($vCurrent, 60))
			EndIf
			If $sCurrent <> $sElapsed Then
				GUICtrlSetData($hLabelPos, $sCurrent)
				$sElapsed = $sCurrent
			EndIf
		EndIf
	EndIf
EndFunc   ;==>_SetProgress


Func _WM_MOVE($hWnd, $iMsg, $wParam, $lParam)
	If IsObj($oVideoWindow) Then $oVideoWindow.NotifyOwnerMessage(Number($hWnd), $iMsg, Number($wParam), Number($lParam))
EndFunc   ;==>_WM_MOVE

Func _WM_SIZE($hWnd, $iMsg, $wParam, $lParam)
	#forceref $iMsg, $wParam
	If $hWnd = $hGUI Then
		Local $aClientSize[2] = [BitAND($lParam, 65535), BitShift($lParam, 16)]
		Local $iX, $iY
		Local $iWidth = $aClientSize[0], $iHeight = $aClientSize[1] - 80
		If IsObj($oBasicVideo) Then
			Local $aCall = $oBasicVideo.GetVideoSize(0, 0)
			If IsArray($aCall) Then
				If $iUnFit Then
					;If $iWidth > $aCall[1] Or $iHeight > $aCall[2] Then
					$iX = ($iWidth - $aCall[1]) / 2
					$iY = ($iHeight - $aCall[2]) / 2
					$iWidth = $aCall[1]
					$iHeight = $aCall[2]
					If $iY + $iHeight + 80 > $aClientSize[1] Then $iY = $aClientSize[1] - 80 - $aCall[2]
					;EndIf
				EndIf
			EndIf
		EndIf
		If IsObj($oVideoWindow) Then $oVideoWindow.SetWindowPosition($iX, $iY, $iWidth, $iHeight)
	EndIf
EndFunc   ;==>_WM_SIZE

Func _WM_GETMINMAXINFO($hWnd, $iMsg, $wParam, $lParam)
	#forceref $iMsg, $wParam
	If $hWnd = $hGUI Then
		Local $tMINMAXINFO = _AutoItObject_DllStructCreate("int;int;" & _
				"int MaxSizeX; int MaxSizeY;" & _
				"int MaxPositionX;int MaxPositionY;" & _
				"int MinTrackSizeX; int MinTrackSizeY;" & _
				"int MaxTrackSizeX; int MaxTrackSizeY", _
				$lParam)
		#forceref $tMINMAXINFO
		$tMINMAXINFO.MinTrackSizeX = 520
		$tMINMAXINFO.MinTrackSizeY = 120
	EndIf
EndFunc   ;==>_WM_GETMINMAXINFO

Func _WM_DROPFILES($hWnd, $iMsg, $wParam, $lParam)
	#forceref $iMsg, $lParam
	If $hWnd = $hGUI Then
		$sMediaFile = _DragQueryFile($wParam)
		If @error Then
			_MessageBeep(48)
			Return 1
		EndIf
		If StringInStr(FileGetAttrib($sMediaFile), "D") Then
			_MessageBeep(48)
			$sMediaFile = ""
		EndIf
		_DragFinish($wParam)
		Return 1
	EndIf
	_MessageBeep(48)
	Return 1
EndFunc   ;==>_WM_DROPFILES

Func _WM_SYSCOMMAND($hWnd, $iMsg, $wParam, $lParam)
	#forceref $iMsg, $lParam
	If $wParam = 0xF120 Or $wParam = 0xF012 Then _InvalidateChild($hWnd) ; SC_RESTORE or (SC_MOVE | HTCAPTION)
EndFunc   ;==>_WM_SYSCOMMAND

Func _WM_COMMAND($hWnd, $iMsg, $wParam, $lParam)
	#forceref $hWnd, $iMsg, $lParam
	If BitShift($wParam, 16) = $THBN_CLICKED Then
		Switch BitAND($wParam, 0xFFFF)
			Case 1000 ; Rew
				If IsObj($oMediaPosition) Then $oMediaPosition.put_CurrentPosition($vCurrent - $vDuration / 100)
			Case 1001 ; Stop
				$oMediaPosition.put_CurrentPosition(0)
				$oMediaControl.Stop()
				GUICtrlSetData($hButtonPlay, "&Play")
				GUICtrlSetData($hLabelPos, "0.0 sec")
				$iPlaying = 0
				$oTaskbarList3.SetProgressValue(Number($hGUI), 0, 100)
			Case 1002 ; Play
				If Not $iPlaying Then
					$oMediaControl.Run()
					GUICtrlSetData($hButtonPlay, "&Pause")
					$iPlaying = 1
				EndIf
			Case 1003 ; Pause
				$oMediaControl.Pause()
				GUICtrlSetData($hButtonPlay, "&Play")
				$iPlaying = 0
			Case 1004 ; Forward
				If IsObj($oMediaPosition) Then $oMediaPosition.put_CurrentPosition($vCurrent + $vDuration / 100)
		EndSwitch
	EndIf
EndFunc   ;==>_WM_COMMAND

Func _WM_TASKBUTT_CREATED($hWnd, $iMsg, $wParam, $lParam)
	#forceref $hWnd, $iMsg, $wParam, $lParam
	; When signaled that taskbar button is created other job can be done
	_CreateTaskBarList($oTaskbarList3)
	; Add buttons to taskbar (Win7)
	_AddTaskbarButtons($hGUI)
	; JumpList (Win7)
	_RegisterExtension($EXTENSIONS, $PROGID, $APPID)
	_CreateJumpList($oCustomDestinationList)
	; If system doesn't support jumplist then unregister registered extensions
	If Not IsObj($oCustomDestinationList) Then _UnRegisterExtension($EXTENSIONS, $PROGID)
EndFunc   ;==>_WM_TASKBUTT_CREATED

Func _InvalidateChild($hWnd)
	If Not $hIWindow Then Return
	Local Static $pFunc = DllCallbackGetPtr(DllCallbackRegister("__EnumChildProc", "bool", "hwnd;lparam"))
	$oUSER32DLL.EnumChildWindows("bool", "hwnd", Number($hWnd), "ptr", Number($pFunc), "lparam", Number($hIWindow))
EndFunc   ;==>_InvalidateChild

Func __EnumChildProc($hWnd, $lParam)
	If $hWnd <> $lParam Then _InvalidateRect($hWnd) ; this means repaint all child windows except $hIWindow ($lParam)
	Return 1
EndFunc   ;==>__EnumChildProc

Func _InvalidateRect($hWnd, $pRect = 0, $fErase = True)
	Local $aCall = $oUSER32DLL.InvalidateRect("bool", _
			"hwnd", Number($hWnd), _
			"ptr", Number($pRect), _
			"bool", $fErase)
	If Not IsArray($aCall) Or Not $aCall[0] Then Return SetError(1, 0, 0)
	Return 1
EndFunc   ;==>_InvalidateRect

Func _MessageBeep($iType)
	$oUSER32DLL.MessageBeep("int", "dword", $iType)
EndFunc   ;==>_MessageBeep

Func _DragQueryFile($hDrop, $iIndex = 0)
	Local $aCall = $oSHELL32DLL.DragQueryFileW("dword", _
			"handle", Number($hDrop), _
			"dword", $iIndex, _
			"wstr", "", _
			"dword", 32767)
	If Not IsArray($aCall) Or Not $aCall[0] Then Return SetError(1, 0, "")
	Return $aCall[3]
EndFunc   ;==>_DragQueryFile

Func _DragFinish($hDrop)
	$oSHELL32DLL.DragFinish("none", "handle", Number($hDrop))
EndFunc   ;==>_DragFinish

Func _SetCurrentProcessExplicitAppUserModelID($sID)
	Local $aCall = $oSHELL32DLL.SetCurrentProcessExplicitAppUserModelID("long", "wstr", $sID)
	If Not IsArray($aCall) Or $aCall[0] Then Return SetError(1, 0, False)
	Return True
EndFunc   ;==>_SetCurrentProcessExplicitAppUserModelID

Func _SHAddFileToRecentDocs($sFile)
	Local $aCall = $oSHELL32DLL.SHAddToRecentDocs("none", "dword", 3, "wstr", $sFile)
	If Not IsArray($aCall) Then Return SetError(1, 0, False)
	Return True
EndFunc   ;==>_SHAddFileToRecentDocs

Func _RegisterExtension($sExtension, $sProgID, $sAppId)
	If StringRight($sExtension, 1) = ";" Then $sExtension = StringTrimRight($sExtension, 1)
	Local $aExtensions = StringSplit($sExtension, ";", 2)
	; Construct the command line
	Local $sCommand = '"' & FileGetLongName(@AutoItExe) & '" "' & @ScriptFullPath & '" "%1"'
	; Write the associations
	For $sExtension In $aExtensions
		If $sExtension Then
			RegWrite("HKCU\Software\Classes\." & $sExtension & "\OpenWithProgIDs", $sProgID, "REG_SZ", "")
			RegWrite("HKCU\Software\Classes\" & $sProgID, "AppUserModelID", "REG_SZ", $sAppId)
			RegWrite("HKCU\Software\Classes\" & $sProgID & "\DefaultIcon", "", "REG_SZ", FileGetLongName(@SystemDir) & "\shell32.dll,118") ; For example
			RegWrite("HKCU\Software\Classes\" & $sProgID & "\shell\open\command", "", "REG_SZ", $sCommand)
		EndIf
	Next
EndFunc   ;==>_RegisterExtension

Func _UnRegisterExtension($sExtension, $sProgID)
	If StringRight($sExtension, 1) = ";" Then $sExtension = StringTrimRight($sExtension, 1)
	Local $aExtensions = StringSplit($sExtension, ";", 2)
	For $sExtension In $aExtensions
		If $sExtension Then
			RegDelete("HKCU\Software\Classes\." & $sExtension & "\OpenWithProgIDs", $sProgID)
			RegDelete("HKCU\Software\Classes\" & $sProgID)
		EndIf
	Next
EndFunc   ;==>_UnRegisterExtension

Func _RegisterMessage($sMessage)
	Local $iMessage = _WinAPI_RegisterWindowMessage($sMessage)
	GUIRegisterMsg($iMessage, "_IntermediaryFunction")
	If $sMediaFile Then
		If AutoItWinGetTitle() <> $WINDOWNAME Then
			WinSetTitle(WinGetHandle($WINDOWNAME), 0, $sMediaFile)
			_SendNotifyMessage(0xFFFF, $iMessage, 1) ; Notify the change (will be caught only by the 'original' instance)
			Exit
		EndIf
	EndIf
	Return $iMessage
EndFunc   ;==>_RegisterMessage

Func _SendNotifyMessage($hWnd, $iMsg, $wParam = 0, $lParam = 0)
	Local $aCall = $oUSER32DLL.SendNotifyMessageW("bool", _
			"hwnd", Number($hWnd), _
			"dword", $iMsg, _
			"wparam", Number($wParam), _
			"lparam", Number($lParam))
	If Not IsArray($aCall) Or Not $aCall[0] Then Return SetError(1, 0, 0)
	Return 1
EndFunc   ;==>_SendNotifyMessage

Func _ChangeWindowMessageFilterEx($hWnd, $iMsg, $iAction)
	Local $aCall = $oUSER32DLL.ChangeWindowMessageFilterEx("bool", _
			"hwnd", Number($hWnd), _
			"dword", $iMsg, _
			"dword", $iAction, _
			"ptr", 0)
	If Not IsArray($aCall) Or Not $aCall[0] Then Return SetError(1, 0, 0)
	Return 1
EndFunc   ;==>_ChangeWindowMessageFilterEx

Func _IntermediaryFunction($hWnd, $iMsg, $wParam, $lParam)
	#forceref $hWnd, $iMsg, $wParam, $lParam
	$sMediaFile = AutoItWinGetTitle()
	If IsAdmin() And $sMediaFile = $WINDOWNAME Then MsgBox(64, "Run elevated", "Run non-elevated to be able to process files like this.", 0, $hWnd)
	AutoItWinSetTitle($WINDOWNAME)
EndFunc   ;==>_IntermediaryFunction

Func _ErrFunc()
;~ 	ConsoleWrite("! COM Error !  Number: 0x" & Hex($oError.number, 8) & "   ScriptLine: " & $oError.scriptline & " - " & $oError.windescription & @CRLF)
EndFunc   ;==>_ErrFunc

Func _CreateStreamOnHGlobal($hGlobal = 0, $iFlag = 1)
	Local $aCall = $oOLE32DLL.CreateStreamOnHGlobal("long", "handle", Number($hGlobal), "int", $iFlag, "ptr*", 0)
	If Not IsArray($aCall) Or $aCall[0] Then Return SetError(1, 0, 0)
	Return $aCall[3]
EndFunc   ;==>_CreateStreamOnHGlobal

Func _GdipCreateHICONFromBitmap($pBitmap)
	Local $aCall = $oGDIPLUSDLL.GdipCreateHICONFromBitmap("dword", "ptr", Number($pBitmap), "handle*", 0)
	If Not IsArray($aCall) Or $aCall[0] Then Return SetError(1, 0, 0)
	Return $aCall[2]
EndFunc   ;==>_GdipCreateHICONFromBitmap

Func _GdipCreateBitmapFromStream($pStream)
	Local $aCall = $oGDIPLUSDLL.GdipCreateBitmapFromStream("dword", "ptr", $pStream, "ptr*", 0)
	If Not IsArray($aCall) Or $aCall[0] Then Return SetError(1, 0, 0)
	Return $aCall[2]
EndFunc   ;==>_GdipCreateBitmapFromStream

Func _CreateHIconFromBinaryImage($bBinary)
	; Create structure (e.g. AutoItObject structure)
	Local $tBinary = _AutoItObject_DllStructCreate("byte Data[" & BinaryLen($bBinary) & "]")
	$tBinary.Data = $bBinary
	; Define ISequentialStream methods:
	Local $dtagISequentialStream = $dtagIUnknown & _
			"Read hresult(ptr;dword;dword*);" & _
			"Write hresult(ptr;dword;dword*);" ; ISequentialStream
	; Create stream
	Local $pStream = _CreateStreamOnHGlobal()
	If @error Then Return SetError(1, 0, 0)
	; Wrapp this interface
	Local $oStream = _AutoItObject_WrapperCreate($pStream, $dtagISequentialStream)
	; Write data to it
	$oStream.Write($tBinary(), $tBinary.__size__, 0)
	; Make bitmap out of the stream
	Local $pBitmap = _GdipCreateBitmapFromStream($oStream.__ptr__)
	If @error Then Return SetError(2, 0, 0)
	; Create Icon out of bitmap
	Local $hIcon = _GdipCreateHICONFromBitmap($pBitmap)
	If @error Then Return SetError(3, 0, 0)
	; Return it:
	Return $hIcon
EndFunc   ;==>_CreateHIconFromBinaryImage

; Few PNGs
Func _BinaryImagePause()
	Return "0x89504E470D0A1A0A0000000D49484452000000100000001008060000001FF3FF61000002684944415478DA636440027C7C9AAC070FAEB6E0E7E795B97CF9C691CB976F3EFEF5EB1783B1B1AEACAEAE86CDC78F9F9FD8DA069DFCF2E5D62F981E466403F6ED3B6A0E54DCC1C9C9A1FEFCF9AB058B17AF6B03199094145E2925259EF8FDFB8F5BE7CF5FAD7070B03C81D5806BD76E55AAAB2BB73001C1F7EF3F1FB6B54D72FEF7EFDFFF9A9AFCBD1C1C1C0AFFFFFFFB77FBF6FD5A0D0D95360C03FEFFFFCF78E5CAAD562D2DD54A90F0AF5FBF5F9595B53881E4BABA6AF6B1B1B18A0155315CBF7EBB5D5B5BAD9A9191F13FBA0B982E5CB8D1AAADA35E01E2000D785D52DC0836A0A7B71E648028887DF5CACD0E03038D6A20F31F8601A7CF5D6FD5D656AFF8FF1F62404519C4808EEEFA7DEC400340565EBB7AB3C3D44813BB01474E5E067A0164C07FB0013595102FB4B6D7EC63051A007436309C6E76D898EB623760FB9E63AD6A6ACA60037EFFFEF3BAB5A9176C404D7DF13E565688176EDDBADBE1E96285DD80F55BF6B5AAA82882C300644057C764279082B2CA5CB801B76FDFEB08F471226CC09F3F4003DA27835D0032808585056CC09D3BF7F11BA0AAAA0475C16F1403887601C80050186073012810F11AB06ED3DE660D4DD52A90C29F3F7FBDEC689DE00C32ACA2BA009812D9C541EC5B37EFB607F838D66035A077C2FC244727DB567E013E913BB7EF1F9CD0372DF9CFEF3FFF8BCB72E6AAAA293B7CFCF8E9EDC10347AB0B73E3E7623140864151495E253A362C5C5C4254FED891933B972F5DB2032413151DEB616963E6FEF2C5EB874B16AD5AF5E0FEC3DB0C0C4F18300C6060F8C6CAC0F04E08C8E0003AE83D0383D42788DC333EA0858240C60F0606A1770C0C5CBF610600003A943E20B7AC701E0000000049454E44AE426082"
EndFunc   ;==>_BinaryImagePause

Func _BinaryImageStop()
	Return "0x89504E470D0A1A0A0000000D49484452000000100000001008060000001FF3FF610000017F4944415478DA6364A01030C218A5A5AD5C8686DA62FFFFFFE364656565C4A6F8F7EFDFFF191999BEAF5EBDE5F9FAF5737EA218B07CF946036F6FE77E1E1E2E43A0302376FBFEFFFFF2E5DBF9B6B6C9091D1D950F510C98336785677C7CE8722626463E7C06FCFBF7FF53767695CBAC599D67500CE8E99D1D989D93B488998989079F9FFFFEFBF7253E36D773D5AA6947500C68EF9C19949D93BC888999891B9F01FFFEFEFB9A109FE3B56ECD8C43280634B54E0BCECC4E5CC8C444C0807FFFBEA624E67B6F5C3FEB208A0155B5BDC189C9514419909F53E5BD6DCB7C54034ACA3B8263E3438932A0ACB8D17BE7F6455436A0B4026440185106941635601A505CD616043460013333330F2323F674F01F08FEFEFDFB05E8029F5D3B16A3C6424C5CA16B544C708784A4B8063E035E3C7F79A3B1BE3BE3E4F18DA7510CE0E3D350E4E5E5D5F9CFF05F8691819115AB010CFF7F03E59EBC79F3F6FCCF9FF79EA018C0C020C309247881181406CC3882E02F107F05E24F0C0C4F7EA019401E00005E2FB3115622B9E40000000049454E44AE426082"
EndFunc   ;==>_BinaryImageStop

Func _BinaryImagePlay()
	Return "0x89504E470D0A1A0A0000000D49484452000000100000001008060000001FF3FF610000027A4944415478DA8D93DF6B526118C7DF73466DBA267511110C62AC8BDD35BAD9C00B63D5741DA435E7555749FD01ED22DA45781304525BA0B5A895D25AD85AE6A8B1A9847646FEA0D439675E8CD2F95B52CFE6D83C7AC6B1E7281B968BFCC2CB0BCFC3F379BECF73CE8B8D8EDE6BE9EF1775B6B5F18F9B4CA44F2623A8AE2E114228861A1166302C9C15897A6F35371FEEC86428B250A00D434337BCC1E01ADD08049B9B335F2588F34F9A9AF0232C5B66699A5ECBE7B7167CBEE06B97CB1B502A6FEE8C8D4DA29191EB0703A6A78DD7E472A90600FC4A00438805954A4C2C9BA58C388ECF6A343ACFE541F1766F4F773D60EA95510100F51EA0566550B158FC99C9E416E1E855AA09F7DB99C785F9C52F889008AB00EDCBF78AE1E12A802D43A0BE470545174B118ADA9C0F87D6DFA492BFBC1D9DA7B6843D12843D7B31ABB82223D41886F3A1218C80D53AA82220C61D98ACCC304C3C97DBF8B0416D6A01E0C11EAAA71484F4220010FFA0C2BF6FEEC05ED07A38AA9D78A4BB8DA91E4C2AC4037D6A1CC7F85C922BAE7552EB885309944E65C2EEAFCB4F755ABDB602905CEA030758DD12F78A393FBB256637164F85963DFE258BD96A226D76177CAFF83E006CD5013815617BE97426E2747CB35A4C368BC36E5F41289D40A87D1BD2EC1F0E6AED8253261A4DFCF079FCA4E1DD477360F5BB9F61B250D8B283508EDD77797FFCB96280B8A00107BC4AC722FC41D178C8E9705B9748A7F5B3D5E281700AA156E81865EBC6BCA31C974B072577793CDEC964221571393DE48CDE68F2AFF856C12A149E808EE9F23FDFC2996EF169D139A1487054D0FEC96CF339ECAE0042781252501863D17F04430B0E2194E71608772B141D2B5417DFD873FE0D5E3042676D8566C50000000049454E44AE426082"
EndFunc   ;==>_BinaryImagePlay

Func _BinaryImageRew()
	Return "0x89504E470D0A1A0A0000000D49484452000000100000001008060000001FF3FF61000003704944415478DA6364C002F4F41C186B6B4BA57978B818DBDA263F3E7C781D5C6EDFBEC30CB76F3FE2535292137FF3E6DD234674CD6969D94C7E7E810ACACA0A8EFFFEFD7D9B9252B6F9F8F18D7F61F2BB771FE0171616B11210E0533A70E0F85A140356ACDCC2222A2220AFA2A218272C2C18F6F9F3979D76764195B76F1FF97EEADC75869FDFBE0A0A0AF038494B4B65B1B0B070AF5CB9311D6EC0D61D4798C54405D525C4451281A687B0B1B1CABF7EFD6E9989B17B46DFA4B62FAF5F3D11747576F69710174DE4E2E230FBFBF7EFEB59B3164530DAD88530F44D6861FEF3EBB7AEB4AC64122F0F57000707BB2C030323C3B3A72F969918B9E44C98D2CE6C6666182C2C2410CFCDCD65C4CCC4C4FEE3C7CF479327CD88658C8A29E02C28CAD016121488E717E00B6563631305EA65FAFF9F81E1E993E7CBFB7AA63665E7A43849488A26727271E9333131B230FC6760FCF9F3E7A389FDD3E21917AFD8A2ABAFAF9D26242418C5CCCC2CC80804202FFD079AF0F4E9F355B76FDDDD67616192CBC1C9A10E94628179F9E7CF5F8FA74E9A19CFB86CD5B640750DE54A1E1E1E632620004982CC0019F0E4C9B3751F3F7C7AABA6AE120D0C134E9014481C240F3260F68CF9F18CE959D59696562629AA6ACAFE404304814E648219F0E8E193F5870F9D3CEEE86493242A26ACC4CACAC20A7321C880797316C5330A8BE84A5B5A1999D939D8845B58183BF30BF00B815C0236E0D1D335457935D33DBD9C9C1C9C6C03E515645481D1C702320464C07C90018C8C6240A77D16B573F0B2F0F276F7373135B01715139104BA93E9F9D3172B3D5D83AA646525257CFD7D3DED1CACBC95951535D9D859D9C106CC5D9400748E0C10FF636365FD276960646C141CECEB676C6AE02C262622F5FAF5DB55FEDEB1B9DFBE7DFA0F4C416AE1D1A16E0E0E36DE4ACA72BA4047BE9A3767493C342101A39DE10B3B300AC5D53474F543C3FC412EB1FDFEEDC79E94A482CA0FEF6F7D6160E01310139750F1F0F470F2F076F6131616605EB16C431152529601E2BF6CC04424A6ACA2A863656D692920C8F760EAE4792BBF7DBDF58D81411A1843FFF825A54494CC2D2C2C35B4D4444F9F3CB7022D33815CF29D8D818149584E5E49564080FFCB8DEBB76FFDFA75EF0F445E1268C8175E21213919496929EE776FDFDDC5C88D1097FC676560F8080CDCDFC05C280AB4FDC97F2479A09E6F5C400C4C545CDF002C932F77D28DBDB30000000049454E44AE426082"
EndFunc   ;==>_BinaryImageRew

Func _BinaryImageFwd()
	Return "0x89504E470D0A1A0A0000000D49484452000000100000001008060000001FF3FF610000039E4944415478DA5D937D4C5B6514C6CFA5834257B6D9AE0BD0AE9A2D25F2D792195DD0B1149468A2663ACDCA882181B139AD2012B328DB4C1423894B60719B99A429E2B22143B6155260CE76B5636D656D85E114BAB67C74A51FB7EDBDED4A696F3FAEEFAD2B519F3FDFE77D7FCF3939EFC1060654ECAD5B7962A773D927918823353555905355D501E8E868D91E8DC6E8CECED3EE7BF77434FC4F98523958229556BE45921167301830D4D64AC339B3B2723F4BA1F8FAF5BC3C16DFE158BC3532726DB1B7F77CE63F00856260974CB6FFBB542AB5EA76AF7C4B90512D9BB391786E770548247B8BF4FAAB5DC5C5DC978341E28ADDBEF0031E2097EA64AFA5D6013D3DBDCF1F3DDAF0238BC512C462F129AF0FEFBBA9D1A804DB44447B6B07D76CB9714120E0D55354720955F993D717E8F3E3C4FCABAFEC4D67015F74F6EC6B693D76B1B0902D4E673289D5D598351822FBA7A67E1F6EFBE0D3B4D9FACBB93261493D000DF178C2F5281ABBEE7679941B0AF267DBDB4EA6B113A74E4B3FFCE8FD7E369B2D060CE84C864EADC562335E0FDE77FE9C42DBFEB1FC33A1A8F4108601C3C850148587C9C8508820FBCF745FB88F1DFFA4AB5ADEFA2E02146CCFF545D3742ABE169F3799CC6725E53B6B84C2D283589690F5E8743A4D8442C4E59999FBBD585BFBE7D5478E356601C883C71769D4F39A6DDE7E69F3964D7C91A8EC0073CEF88C3248D168D4323FE7E8C2E4AD27AB9B9A1BD62B601292C95412F7079DB7B493CAAA7D7B2AC54F8ADECC01508BCC63E281CDA1321ACC0A4CDE72A2BAF13180798CC6995A5A7CF840A7BD7D6D7C4CABEDFEE6CBF7C462E1DB0C80490E93E190C964D1E87593834683750A558000871BBE6700542299703816FED2EB0CEA51D5E8B8CBE5F18EDFBCFA55A9B04486E233B83FE031DF9DFE754C7D43A5D78D99008A710438256D6A7EA71FC1B7391DCBB33ADDA47AF0D2D0CF0441DA389C4D984A7DF1AC40C03FE8F707562C77A735C3C3A323D3568B3599CCF300E4515863F3F117EAEADFE80E06C9F4845A3332313EA1F5FBBC768008B9E58972AE4279A6AB8853F8124ABE3D7445A5B2CDCDCEA051FA00B8090017602FD61EAA7876CFEEBAB93F6DF86F2693D1B312702232DA077786B3B19C236F69929144E429C31DA3D1615FF8037D263F008B0278F8CF572E2D7B86CFE3F3767ADC2BABA1D0323AE53E02F06417A6A060C786A72B24E52419E62E2F395D68804180228A495EDF05005E3E408C03C0410BC28921F2BF5656847C1C79F92C80CD6BE87A32979CD3DF4A35F5D2E898B05B0000000049454E44AE426082"
EndFunc   ;==>_BinaryImageFwd